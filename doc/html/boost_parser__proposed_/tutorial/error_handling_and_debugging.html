<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Error Handling and Debugging</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="callback_parsing.html" title="Callback Parsing">
<link rel="next" href="memory_allocation.html" title="Memory Allocation">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="callback_parsing.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="memory_allocation.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging"></a><a class="link" href="error_handling_and_debugging.html" title="Error Handling and Debugging">Error
      Handling and Debugging</a>
</h3></div></div></div>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h0"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.error_handling"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging.error_handling">Error
        handling</a>
      </h5>
<p>
        Boost.Parser has good error reporting built into it. Consider what happens
        when we fail to parse at an expectation point (created using <code class="computeroutput"><span class="keyword">operator</span><span class="special">&gt;</span></code>).
        If I feed the parser from the <a class="link" href="../extended_examples/parsing_json_with_callbacks.html" title="Parsing JSON With Callbacks">Parsing
        JSON With Callbacks</a> example a file called sample.json containing this
        input (note the unmatched <code class="computeroutput"><span class="char">'['</span></code>):
      </p>
<p>
</p>
<pre class="programlisting">{
    "key": "value",
    "foo": [, "bar": []
}
</pre>
<p>
      </p>
<p>
        This is the error message that is printed to the terminal:
      </p>
<p>
</p>
<pre class="programlisting">sample.json:3:12: error: Expected ']' here:
    "foo": [, "bar": []
            ^
</pre>
<p>
      </p>
<p>
        That message is formatted like the diagnostics produced by Clang and GCC.
        It quotes the line on which the failure occurred, and even puts a caret under
        the exact position at which the parse failed. This error message is suitable
        for many kinds of end-users, and interoperates well with anything that supports
        Clang and/or GCC diagnostics.
      </p>
<p>
        Most of Boost.Parser's error handlers format their diagnostics this way,
        though you are not bound by that. You can make an error handler type that
        does whatever you want, as long as it meets the error handler interface.
      </p>
<p>
        The Boost.Parser error handlers are:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/parser/default_error_handler.html" title="Struct default_error_handler">default_error_handler</a></code>:
            Produces formatted diagnostics like the one above, and prints them to
            <code class="computeroutput">std::cerr</code>. <code class="computeroutput"><a class="link" href="../../boost/parser/default_error_handler.html" title="Struct default_error_handler">default_error_handler</a></code> has
            no associated file name, and both errors and diagnostics are printed
            to <code class="computeroutput">std::cerr</code>. This handler is <code class="computeroutput">constexpr</code>-friendly.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/parser/stream_error_handler.html" title="Struct stream_error_handler">stream_error_handler</a></code>:
            Produces formatted diagnostics. One or two streams may be used. If two
            are used, errors go to one stream and warnings go to the other. A file
            name can be associated with the parse; if it is, that file name will
            appear in all diagnostics.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/parser/callback_error_handler.html" title="Struct callback_error_handler">callback_error_handler</a></code>:
            Produces formatted diagnostics. Calls a callback with the diagnostic
            message to report the diagnostic, rather than streaming out the diagnostic.
            A file name can be associated with the parse; if it is, that file name
            will appear in all diagnostics. This handler is useful for recording
            the diagnostics in memory.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/parser/rethrow_error_handler.html" title="Struct rethrow_error_handler">rethrow_error_handler</a></code>:
            Does nothing but re-throw any exception that it is asked to handle. Its
            <code class="computeroutput">diagnose()</code> member functions are no-ops.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/parser/vs_output_error_handler.html" title="Struct vs_output_error_handler">vs_output_error_handler</a></code>:
            Directs all errors and warnings to the debugging output panel inside
            Visual Studio. Available on Windows only. Probably does nothing useful
            desirable when executed outside of Visual Studio.
          </li>
</ul></div>
<p>
        You can set the error handler to any of these, or one of your own, using
        <code class="computeroutput"><a class="link" href="../../boost/parser/with_error_handler.html" title="Function template with_error_handler">with_error_handler()</a></code> (see <a class="link" href="the__parse____api.html" title="The parse() API">The
        <code class="computeroutput"><span class="identifier">parse</span><span class="special">()</span></code>
        API</a>). If you do not set one, <code class="computeroutput"><a class="link" href="../../boost/parser/default_error_handler.html" title="Struct default_error_handler">default_error_handler</a></code> will
        be used.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h1"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.how_diagnostics_are_generated"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging.how_diagnostics_are_generated">How
        diagnostics are generated</a>
      </h5>
<p>
        Boost.Parser only generates error messages like the ones in this page at
        failed expectation points, like <code class="computeroutput">a &gt; b</code>, where you have successfully
        parsed <code class="computeroutput">a</code>, but then cannot successfully parse <code class="computeroutput">b</code>.
        This may seem limited to you. It's actually the best that we can do.
      </p>
<p>
        In order for error handling to happen other than at expectation points, we
        have to know that there is no further processing that might take place. This
        is true because Boost.Parser has <code class="computeroutput">P1 | P2 | ... | Pn</code> parsers
        ("<code class="computeroutput">or_parser</code>s"). If any one of these parsers <code class="computeroutput">Pi</code>
        fails to match, it is not allowed to fail the parse — the next one
        (<code class="computeroutput">Pi+1</code>) might match. If we get to the end of the alternatives
        of the or_parser and <code class="computeroutput">Pn</code> fails, we still cannot fail the top-level
        parse, because the <code class="computeroutput">or_parser</code> might be a subparser within a parent
        <code class="computeroutput">or_parser</code>.
      </p>
<p>
        Ok, so what might we do? Perhaps we could at least indicate when we ran into
        end-of-input. But we cannot, for exactly the same reason already stated.
        For any parser <code class="computeroutput">P</code>, reaching end-of-input is a failure for <code class="computeroutput">P</code>,
        but not necessarily for the whole parse.
      </p>
<p>
        Perhaps we could record the farthest point ever reached during the parse,
        and report that at the top level, if the top level parser fails. That would
        be little help without knowing which parser was active when we reached that
        point. This would require some sort of repeated memory allocation, since
        in Boost.Parser the progress point of the parser is stored exclusively on
        the stack — by the time we fail the top-level parse, all those far-reaching
        stack frames are long gone. Not the best.
      </p>
<p>
        Worse still, knowing how far you got in the parse and which parser was active
        is not very useful. Consider this.
      </p>
<pre class="programlisting">namespace bp = boost::parser;
auto a_b = bp::char_('a') &gt;&gt; bp::char_('b');
auto c_b = bp::char_('c') &gt;&gt; bp::char_('b');
auto result = bp::parse("acb", a_b | c_b);
</pre>
<p>
        If we reported the farthest-reaching parser and it's position, it would be
        the <code class="computeroutput">a_b</code> parser, at position <code class="computeroutput">"bc"</code> in the
        input. Is this really enlightening? Was the error in the input putting the
        <code class="computeroutput">'a'</code> at the beginning or putting the <code class="computeroutput">'c'</code> in the
        middle? If you point the user at <code class="computeroutput">a_b</code> as the parser that failed,
        and never mention <code class="computeroutput">c_b</code>, you are potentially just steering them
        in the wrong direction.
      </p>
<p>
        All error messages must come from failed expectation points. Consider parsing
        JSON. If you open a list with <code class="computeroutput">'['</code>, you know that you're parsing
        a list, and if the list is ill-formed, you'll get an error message saying
        so. If you open an object with <code class="computeroutput">'{'</code>, the same thing is possible
        — when missing the matching <code class="computeroutput">'}'</code>, you can tell the user,
        "That's not an object", and this is useful feedback. The same thing
        with a partially parsed number, etc. If the JSON parser does not build in
        expectations like matched braces and brackets, how can Boost.Parser know
        that a missing <code class="computeroutput">'}'</code> is really a problem, and that no later parser
        will match the input even without the <code class="computeroutput">'}'</code>?
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
          The bottom line is that you should build expectation points into your parsers
          using <code class="computeroutput">operator&gt;</code> as much as possible.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h2"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.using_error_handlers_in_semantic_actions"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging.using_error_handlers_in_semantic_actions">Using
        error handlers in semantic actions</a>
      </h5>
<p>
        You can get access to the error handler within any semantic action by calling
        <code class="computeroutput">_error_handler(ctx)</code> (see <a class="link" href="the_parse_context.html" title="The Parse Context">The
        Parse Context</a>). Any error handler must have the following member functions:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Iter</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">diagnose</span><span class="special">(</span>
    <span class="identifier">diagnostic_kind</span> <span class="identifier">kind</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">message</span><span class="special">,</span>
    <span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">context</span><span class="special">,</span>
    <span class="identifier">Iter</span> <span class="identifier">it</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">diagnose</span><span class="special">(</span>
    <span class="identifier">diagnostic_kind</span> <span class="identifier">kind</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">message</span><span class="special">,</span>
    <span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">context</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        If you call the second one, the one without the iterator parameter, it will
        call the first with <code class="computeroutput"><a class="link" href="../../boost/parser/_where.html" title="Function template _where">_where</a>(context).begin()</code>
        as the iterator parameter. The one without the iterator is the one you will
        use most often. The one with the explicit iterator parameter can be useful
        in situations where you have messages that are related to each other, associated
        with multiple locations. For instance, if you are parsing XML, you may want
        to report that a close-tag does not match its associated open-tag by showing
        the line where the open-tag was found. That may of course not be located
        anywhere near <code class="computeroutput">_where(ctx).begin()</code>. (A description of <code class="computeroutput"><a class="link" href="../../boost/parser/_globals.html" title="Function template _globals">_globals()</a></code> is below.)
      </p>
<pre class="programlisting">[](auto &amp; ctx) {
    // Assume we have a std::vector of open tags, and another
    // std::vector of iterators to where the open tags were parsed, in our
    // globals.
    if (_attr(ctx) != _globals(ctx).open_tags.back()) {
        std::string open_tag_msg =
            "Previous open-tag \"" + _globals(ctx).open_tags.back() + "\" here:";
        _error_handler(ctx).diagnose(
            boost::parser::diagnostic_kind::error,
            open_tag_msg,
            ctx,
            _globals(ctx).open_tags_position.back());
        std::string close_tag_msg =
            "does not match close-tag \"" + _attr(ctx) + "\" here:";
        _error_handler(ctx).diagnose(
            boost::parser::diagnostic_kind::error,
            close_tag_msg,
            ctx);

        // Explicitly fail the parse.  Diagnostics do not affect parse success.
        _pass(ctx) = false;
    }
}
</pre>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h3"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging._functionname_alt__boost__parser___report_error___code__phrase_role__identifier___report_error__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___report_warning___code__phrase_role__identifier___report_warning__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging._functionname_alt__boost__parser___report_error___code__phrase_role__identifier___report_error__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___report_warning___code__phrase_role__identifier___report_warning__phrase__phrase_role__special______phrase___code___functionname_">_report_error() and _report_warning()</a>
      </h5>
<p>
        There are also some convenience functions that make the above code a little
        less verbose, <code class="computeroutput"><a class="link" href="../../boost/parser/report_error_idm33470.html" title="Function template _report_error">_report_error()</a></code>
        and <code class="computeroutput"><a class="link" href="../../boost/parser/report_warning_idm33498.html" title="Function template _report_warning">_report_warning()</a></code>:
      </p>
<pre class="programlisting">[](auto &amp; ctx) {
    // Assume we have a std::vector of open tags, and another
    // std::vector of iterators to where the open tags were parsed, in our
    // globals.
    if (_attr(ctx) != _globals(ctx).open_tags.back()) {
        std::string open_tag_msg =
            "Previous open-tag \"" + _globals(ctx).open_tags.back() + "\" here:";
        _report_error(ctx, open_tag_msg, _globals(ctx).open_tag_positions.back());
        std::string close_tag_msg =
            "does not match close-tag \"" + _attr(ctx) + "\" here:";
        _report_error(ctx, close_tag_msg);

        // Explicitly fail the parse.  Diagnostics do not affect parse success.
        _pass(ctx) = false;
    }
}
</pre>
<p>
        You should use these less verbose functions almost all the time. The only
        time you would want to use <code class="computeroutput"><a class="link" href="../../boost/parser/_error_handler.html" title="Function template _error_handler">_error_handler()</a></code>
        directly is when you are using a custom error handler, and you want access
        to some part of its interface besides <code class="computeroutput">diagnose()</code>.
      </p>
<p>
        Though there is support for reporting warnings using the functions above,
        none of the error handlers supplied by Boost.Parser will ever report a warning.
        Warnings are strictly for user code.
      </p>
<p>
        For more information on the rest of the error handling and diagnostic API,
        see the header reference pages for <code class="computeroutput"><a class="link" href="../../header/boost/parser/error_handling_fwd_hpp.html" title="Header &lt;boost/parser/error_handling_fwd.hpp&gt;">error_handling_fwd.hpp</a></code>
        and <code class="computeroutput"><a class="link" href="../../header/boost/parser/error_handling_hpp.html" title="Header &lt;boost/parser/error_handling.hpp&gt;">error_handling.hpp</a></code>.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h4"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.creating_your_own_error_handler"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging.creating_your_own_error_handler">Creating
        your own error handler</a>
      </h5>
<p>
        Creating your own error handler is pretty easy; you just need to implement
        three member functions. Say you want an error handler that writes diagnostics
        to a file. Here's how you might do that.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">logging_error_handler</span>
<span class="special">{</span>
    <span class="identifier">logging_error_handler</span><span class="special">()</span> <span class="special">{}</span>
    <span class="identifier">logging_error_handler</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">filename</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">filename_</span><span class="special">(</span><span class="identifier">filename</span><span class="special">),</span> <span class="identifier">ofs_</span><span class="special">(</span><span class="identifier">filename_</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">ofs_</span><span class="special">)</span>
            <span class="keyword">throw</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span><span class="string">"Could not open file."</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// This is the function called by Boost.Parser after a parser fails the</span>
    <span class="comment">// parse at an expectation point and throws a parse_error.  It is expected</span>
    <span class="comment">// to create a diagnostic message, and put it where it needs to go.  In</span>
    <span class="comment">// this case, we're writing it to a log file.  This function returns a</span>
    <span class="comment">// bp::error_handler_result, which is an enum with two enumerators -- fail</span>
    <span class="comment">// and rethrow.  Returning fail fails the top-level parse; returning</span>
    <span class="comment">// rethrow just re-throws the parse_error exception that got us here in</span>
    <span class="comment">// the first place.</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iter</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Sentinel</span><span class="special">&gt;</span>
    <span class="identifier">bp</span><span class="special">::</span><span class="identifier">error_handler_result</span>
    <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Iter</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Sentinel</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse_error</span><span class="special">&lt;</span><span class="identifier">Iter</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">e</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">bp</span><span class="special">::</span><span class="identifier">write_formatted_expectation_failure_error_message</span><span class="special">(</span>
            <span class="identifier">ofs_</span><span class="special">,</span> <span class="identifier">filename_</span><span class="special">,</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">e</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">error_handler_result</span><span class="special">::</span><span class="identifier">fail</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// This function is for users to call within a semantic action to produce</span>
    <span class="comment">// a diagnostic.</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Iter</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">diagnose</span><span class="special">(</span>
        <span class="identifier">bp</span><span class="special">::</span><span class="identifier">diagnostic_kind</span> <span class="identifier">kind</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">message</span><span class="special">,</span>
        <span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">context</span><span class="special">,</span>
        <span class="identifier">Iter</span> <span class="identifier">it</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">bp</span><span class="special">::</span><span class="identifier">write_formatted_message</span><span class="special">(</span>
            <span class="identifier">ofs_</span><span class="special">,</span>
            <span class="identifier">filename_</span><span class="special">,</span>
            <span class="identifier">bp</span><span class="special">::</span><span class="identifier">_begin</span><span class="special">(</span><span class="identifier">context</span><span class="special">),</span>
            <span class="identifier">it</span><span class="special">,</span>
            <span class="identifier">bp</span><span class="special">::</span><span class="identifier">_end</span><span class="special">(</span><span class="identifier">context</span><span class="special">),</span>
            <span class="identifier">message</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// This is just like the other overload of diagnose(), except that it</span>
    <span class="comment">// determines the Iter parameter for the other overload by calling</span>
    <span class="comment">// _where(ctx).</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">diagnose</span><span class="special">(</span>
        <span class="identifier">bp</span><span class="special">::</span><span class="identifier">diagnostic_kind</span> <span class="identifier">kind</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">message</span><span class="special">,</span>
        <span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">context</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">diagnose</span><span class="special">(</span><span class="identifier">kind</span><span class="special">,</span> <span class="identifier">message</span><span class="special">,</span> <span class="identifier">context</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">_where</span><span class="special">(</span><span class="identifier">context</span><span class="special">).</span><span class="identifier">begin</span><span class="special">());</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">filename_</span><span class="special">;</span>
    <span class="keyword">mutable</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ofstream</span> <span class="identifier">ofs_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        That's it. You just need to do the important work of the error handler in
        its call operator, and then implement the two overloads of <code class="computeroutput">diagnose()</code>
        that it must provide for use inside semantic actions. The default implementation
        of these is even available as the free function <code class="computeroutput">write_formatted_message()</code>,
        so you can just call that, as you see above. Here's how you might use it.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Enter a list of integers, separated by commas. "</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">input</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">getline</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cin</span><span class="special">,</span> <span class="identifier">input</span><span class="special">);</span>

    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">parser</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="char">','</span> <span class="special">&gt;</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span><span class="special">);</span>
    <span class="identifier">logging_error_handler</span> <span class="identifier">error_handler</span><span class="special">(</span><span class="string">"parse.log"</span><span class="special">);</span>
    <span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">with_error_handler</span><span class="special">(</span><span class="identifier">parser</span><span class="special">,</span> <span class="identifier">error_handler</span><span class="special">));</span>

    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"It looks like you entered:\n"</span><span class="special">;</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span> <span class="special">:</span> <span class="special">*</span><span class="identifier">result</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        We just define a <code class="computeroutput">logging_error_handler</code>, and pass it by reference
        to <code class="computeroutput"><a class="link" href="../../boost/parser/with_error_handler.html" title="Function template with_error_handler">with_error_handler()</a></code>, which decorates the top-level
        parser with the error handler. We <span class="bold"><strong>could not</strong></span>
        have written <code class="computeroutput">bp::with_error_handler(parser, logging_error_handler("parse.log"))</code>,
        because <code class="computeroutput"><a class="link" href="../../boost/parser/with_error_handler.html" title="Function template with_error_handler">with_error_handler()</a></code>
        does not accept rvalues. This is becuse the error handler eventually goes
        into the parse context. The parse context only stores pointers and iterators,
        keeping it cheap to copy.
      </p>
<p>
        If we run the example and give it the input <code class="computeroutput">"1,"</code>,
        this shows up in the log file:
      </p>
<pre class="programlisting">parse.log:1:2: error: Expected int_ here (end of input):
1,
  ^
</pre>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h5"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.fixing_ill_formed_code"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging.fixing_ill_formed_code">Fixing
        ill-formed code</a>
      </h5>
<p>
        Sometimes, during the writing of a parser, you make a simple mistake that
        is diagnosed horrifyingly, due to the high number of template instantiations
        between the line you just wrote and the point of use (usually, the call to
        <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32573.html" title="Function template parse">parse()</a></code>). By "sometimes",
        I mean "almost always and many, many times". Boost.Parser has a
        workaround for situations like this. The workaround is to make the ill-formed
        code well-formed in as many circumstances as possible, and then do a runtime
        assert instead.
      </p>
<p>
        Usually, C++ programmers try whenever they can to catch mistakes as early
        as they can. That usually means making as much bad code ill-formed as possible.
        Counter-intuitively, this does not work well in parser combinator situations.
        For an example of just how dramatically different these two debugging scenarios
        can be with Boost.Parser, please see the very long discussion in the <a class="link" href="../rationale.html#boost_parser__proposed_.rationale._classname_alt__boost__parser__none___code__phrase_role__identifier__none__phrase___code___classname__is_weird"><code class="computeroutput"><span class="identifier">none</span></code> is weird</a> section of <a class="link" href="../rationale.html" title="Rationale">Rationale</a>.
      </p>
<p>
        If you are morally opposed to this approach, or just hate fun, good news:
        you can turn off the use of this technique entirely by defining <code class="computeroutput">BOOST_PARSER_NO_RUNTIME_ASSERTIONS</code>.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h6"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.runtime_debugging"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging.runtime_debugging">Runtime
        debugging</a>
      </h5>
<p>
        Debugging parsers is hard. Any parser above a certain complexity level is
        nearly impossible to debug simply by looking at the parser's code. Stepping
        through the parse in a debugger is even worse. To provide a reasonable chance
        of debugging your parsers, Boost.Parser has a trace mode that you can turn
        on simply by providing an extra parameter to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32573.html" title="Function template parse">parse()</a></code>
        or <code class="computeroutput"><a class="link" href="../../boost/parser/callback_parse_idm32861.html" title="Function template callback_parse">callback_parse()</a></code>:
      </p>
<pre class="programlisting">boost::parser::parse(input, parser, boost::parser::trace::on);
</pre>
<p>
        Every overload of <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32573.html" title="Function template parse">parse()</a></code>
        and <code class="computeroutput"><a class="link" href="../../boost/parser/callback_parse_idm32861.html" title="Function template callback_parse">callback_parse()</a></code> takes this final parameter,
        which is defaulted to <code class="computeroutput"><a class="link" href="../../boost/parser/trace.html" title="Type trace">boost::parser::trace</a>::off</code>.
      </p>
<p>
        If we trace a substantial parser, we will see a <span class="bold"><strong>lot</strong></span>
        of output. Each code point of the input must be considered, one at a time,
        to see if a certain rule matches. An an example, let's trace a parse using
        the JSON parser from <a class="link" href="../extended_examples/parsing_json.html" title="Parsing JSON">Parsing
        JSON</a>. The input is <code class="computeroutput">"null"</code>. <code class="computeroutput">null</code>
        is one of the types that a Javascript value can have; the top-level parser
        in the JSON parser example is:
      </p>
<pre class="programlisting">auto const value_p_def =
    number | bp::bool_ | null | string | array_p | object_p;
</pre>
<p>
        So, a JSON value can be a number, or a Boolean, a <code class="computeroutput">null</code>, etc.
        During the parse, each alternative will be tried in turn, until one is matched.
        I picked <code class="computeroutput">null</code> because it is relatively close to the beginning
        of the <code class="computeroutput">value_p_def</code> alternative parser. Even so, the output is
        pretty huge. Let's break it down as we go:
      </p>
<p>
</p>
<pre class="programlisting">[begin value; input="null"]
</pre>
<p>
      </p>
<p>
        Each parser is traced as <code class="computeroutput">[begin foo; ...]</code>, then the parsing
        operations themselves, and then <code class="computeroutput">[end foo; ...]</code>. The name of
        a rule is used as its name in the <code class="computeroutput">begin</code> and <code class="computeroutput">end</code>
        parts of the trace. Non-rules have a name that is similar to the way the
        parser looked when you wrote it. Most lines will have the next few code points
        of the input quoted, as we have here (<code class="computeroutput">input="null"</code>).
      </p>
<p>
</p>
<pre class="programlisting">[begin number | bool_ | null | string | ...; input="null"]
</pre>
<p>
      </p>
<p>
        This shows the beginning of the parser <span class="bold"><strong>inside</strong></span>
        the rule <code class="computeroutput">value</code> — the parser that actually does all the
        work. In the example code, this parser is called <code class="computeroutput">value_p_def</code>.
        Since it isn't a rule, we have no name for it, so we show its implementation
        in terms of subparsers. Since it is a bit long, we don't print the entire
        thing. That's why that ellipsis is there.
      </p>
<p>
</p>
<pre class="programlisting">[begin number; input="null"]
  [begin raw[lexeme[ &gt;&gt; ...]][&lt;&lt;action&gt;&gt;]; input="null"]
</pre>
<p>
      </p>
<p>
        Now we're starting to see the real work being done. <code class="computeroutput">number</code> is
        a somewhat complicated parser that does not match <code class="computeroutput">"null"</code>,
        so there's a lot to wade through when following the trace of its attempt
        to do so. One thing to note is that, since we cannot print a name for an
        action, we just print <code class="computeroutput">"&lt;&lt;action&gt;&gt;"</code>. Something
        similar happens when we come to an attribute that we cannot print, because
        it has no stream insertion operation. In that case, <code class="computeroutput">"&lt;&lt;unprintable-value&gt;&gt;"</code>
        is printed.
      </p>
<p>
</p>
<pre class="programlisting">    [begin raw[lexeme[ &gt;&gt; ...]]; input="null"]
      [begin lexeme[-char_('-') &gt;&gt; char_('1', '9') &gt;&gt; ... | ... &gt;&gt; ...]; input="null"]
        [begin -char_('-') &gt;&gt; char_('1', '9') &gt;&gt; *digit | char_('0') &gt;&gt; -(char_('.') &gt;&gt; ...) &gt;&gt; -( &gt;&gt; ...); input="null"]
          [begin -char_('-'); input="null"]
            [begin char_('-'); input="null"]
              no match
            [end char_('-'); input="null"]
            matched ""
            attribute: &lt;&lt;empty&gt;&gt;
          [end -char_('-'); input="null"]
          [begin char_('1', '9') &gt;&gt; *digit | char_('0'); input="null"]
            [begin char_('1', '9') &gt;&gt; *digit; input="null"]
              [begin char_('1', '9'); input="null"]
                no match
              [end char_('1', '9'); input="null"]
              no match
            [end char_('1', '9') &gt;&gt; *digit; input="null"]
            [begin char_('0'); input="null"]
              no match
            [end char_('0'); input="null"]
            no match
          [end char_('1', '9') &gt;&gt; *digit | char_('0'); input="null"]
          no match
        [end -char_('-') &gt;&gt; char_('1', '9') &gt;&gt; *digit | char_('0') &gt;&gt; -(char_('.') &gt;&gt; ...) &gt;&gt; -( &gt;&gt; ...); input="null"]
        no match
      [end lexeme[-char_('-') &gt;&gt; char_('1', '9') &gt;&gt; ... | ... &gt;&gt; ...]; input="null"]
      no match
    [end raw[lexeme[ &gt;&gt; ...]]; input="null"]
    no match
  [end raw[lexeme[ &gt;&gt; ...]][&lt;&lt;action&gt;&gt;]; input="null"]
  no match
[end number; input="null"]
[begin bool_; input="null"]
  no match
[end bool_; input="null"]
</pre>
<p>
      </p>
<p>
        <code class="computeroutput">number</code> and <code class="computeroutput">boost::parser::bool_</code> did not match,
        but <code class="computeroutput">null</code> will:
      </p>
<p>
</p>
<pre class="programlisting">[begin null; input="null"]
  [begin "null" &gt;&gt; attr(null); input="null"]
    [begin "null"; input="null"]
      [begin string("null"); input="null"]
        matched "null"
        attribute:
      [end string("null"); input=""]
      matched "null"
      attribute: null
</pre>
<p>
      </p>
<p>
        Finally, this parser actually matched, and the match generated the attribute
        <code class="computeroutput">null</code>, which is a special value of the type <code class="computeroutput">json::value</code>.
        Since we were matching a string literal <code class="computeroutput">"null"</code>, earlier
        there was no attribute until we reached the <code class="computeroutput">attr(null)</code> parser.
      </p>
<p>
</p>
<pre class="programlisting">        [end "null"; input=""]
        [begin attr(null); input=""]
          matched ""
          attribute: null
        [end attr(null); input=""]
        matched "null"
        attribute: null
      [end "null" &gt;&gt; attr(null); input=""]
      matched "null"
      attribute: null
    [end null; input=""]
    matched "null"
    attribute: null
  [end number | bool_ | null | string | ...; input=""]
  matched "null"
  attribute: null
[end value; input=""]
--------------------
parse succeeded
--------------------
</pre>
<p>
      </p>
<p>
        At the very end of the parse, the trace code prints out whether the top-level
        parse succeeded or failed.
      </p>
<p>
        Some things to be aware of when looking at Boost.Parser trace output:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            There are some parsers you don't know about, because they are not directly
            documented. For instance, <code class="computeroutput">p[a]</code> forms an <code class="computeroutput">action_parser</code>
            containing the parser <code class="computeroutput">p</code> and semantic action <code class="computeroutput">a</code>.
            This is essentially an implementation detail, but unfortunately the trace
            output does not hide this from you.
          </li>
<li class="listitem">
            For a parser <code class="computeroutput">p</code>, the trace-name may be intentionally different
            from the actual structure of <code class="computeroutput">p</code>. For example, in the trace
            above, you see a parser called simply <code class="computeroutput">"null"</code>.
            This parser is actually <code class="computeroutput">boost::parser::omit[boost::parser::string("null")]</code>,
            but what you typically write is just <code class="computeroutput">"null"</code>, so
            that's the name used. There are two special cases like this: the one
            described here for <code class="computeroutput">omit[string]</code>, and another for <code class="computeroutput">omit[char_]</code>.
          </li>
<li class="listitem">
            Since there are no other special cases for how parser names are printed,
            you may see parsers that are unlike what you wrote in your code. In the
            sections about the parsers and combining operations, you will sometimes
            see a parser or combining operation described in terms of an equivalent
            parser. For example, <code class="computeroutput">if_(pred)[p]</code> is described as "Equivalent
            to <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a>(pred)
            &gt;&gt; p</code>". In a trace, you will not see <code class="computeroutput">if_</code>;
            you will see <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
            and <code class="computeroutput">p</code> instead.
          </li>
<li class="listitem">
            The values of arguments passed to parsers is printed whenever possible.
            Sometimes, a parse argument is not a value itself, but a callable that
            produces that value. In these cases, you'll see the resolved value of
            the parse argument.
          </li>
</ul></div>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="callback_parsing.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="memory_allocation.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
