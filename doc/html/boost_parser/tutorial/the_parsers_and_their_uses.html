<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The Parsers And Their Uses</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="mutable_symbol_tables.html" title="Mutable Symbol Tables">
<link rel="next" href="directives.html" title="Directives">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="mutable_symbol_tables.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="directives.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser.tutorial.the_parsers_and_their_uses"></a><a class="link" href="the_parsers_and_their_uses.html" title="The Parsers And Their Uses">The
      Parsers And Their Uses</a>
</h3></div></div></div>
<p>
        Boost.Parser comes with all the parsers most parsing tasks will ever need.
        Each one is a <code class="computeroutput"><span class="keyword">constexpr</span></code> object,
        or a <code class="computeroutput"><span class="keyword">constexpr</span></code> function. Some
        of the non-functions are also callable, such as <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, which may be used directly,
        or with arguments, as in <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a><span class="special">(</span><span class="char">'a'</span><span class="special">,</span> <span class="char">'z'</span><span class="special">)</span></code>. Any parser that can be called, whether
        a function or callable object, will be called a <span class="emphasis"><em>callable parser</em></span>
        from now on. Note that there are no nullary callable parsers; they each take
        one or more arguments.
      </p>
<p>
        Each callable parser takes one or more <span class="emphasis"><em>parse arguments</em></span>.
        A parse argument may be a value or an invocable object that accepts a reference
        to the parse context. The reference parameter may be mutable or constant.
        For example:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">get_attribute</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
    <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Context</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        This can also be a lambda. For example:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span> <span class="special">}</span>
</pre>
<p>
        The operation that produces a value from a parse argument, which may be a
        value or a callable taking a parse context argument, is referred to as <span class="emphasis"><em>resolving</em></span>
        the parse argument. If a parse argument <code class="computeroutput"><span class="identifier">arg</span></code>
        can be called with the current context, then the resolved value of <code class="computeroutput"><span class="identifier">arg</span></code> is <code class="computeroutput"><span class="identifier">arg</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>;
        otherwise, the resolved value is just <code class="computeroutput"><span class="identifier">arg</span></code>.
      </p>
<p>
        Some callable parsers take a <span class="emphasis"><em>parse predicate</em></span>. A parse
        predicate is not quite the same as a parse argument, because it must be a
        callable object, and cannot be a value. A parse predicate's return type must
        be contextually convertible to <code class="computeroutput"><span class="keyword">bool</span></code>.
        For example:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">equals_three</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">==</span> <span class="number">3</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        This may of course be a lambda:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">==</span> <span class="number">3</span><span class="special">;</span> <span class="special">}</span>
</pre>
<p>
        The notional macro <span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><code class="computeroutput"><span class="special">()</span></code> expands to the result of resolving a parse
        argument or parse predicate. You'll see it used in the rest of the documentation.
      </p>
<p>
        An example of how parse arguments are used:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="comment">// This parser matches one code point that is at least 'a', and at most</span>
<span class="comment">// the value of last_char, which comes from the globals.</span>
<span class="keyword">auto</span> <span class="identifier">last_char</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">last_char</span><span class="special">;</span> <span class="special">}</span>
<span class="keyword">auto</span> <span class="identifier">subparser</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'a'</span><span class="special">,</span> <span class="identifier">last_char</span><span class="special">);</span>
</pre>
<p>
        Don't worry for now about what the globals are for now; the take-away is
        that you can make any argument you pass to a parser depend on the current
        state of the parse, by using the parse context:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="comment">// This parser parses two code points.  For the parse to succeed, the</span>
<span class="comment">// second one must be &gt;= 'a' and &lt;= the first one.</span>
<span class="keyword">auto</span> <span class="identifier">set_last_char</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">last_char</span> <span class="special">=</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span> <span class="special">};</span>
<span class="keyword">auto</span> <span class="identifier">parser</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">char_</span><span class="special">[</span><span class="identifier">set_last_char</span><span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="identifier">subparser</span><span class="special">;</span>
</pre>
<p>
        Each callable parser returns a new parser, parameterized using the arguments
        given in the invocation.
      </p>
<p>
        This table lists all the Boost.Parser parsers. For the callable parsers,
        a separate entry exists for each possible arity of arguments. For a parser
        <code class="computeroutput"><span class="identifier">p</span></code>, if there is no entry for
        <code class="computeroutput"><span class="identifier">p</span></code> without arguments, <code class="computeroutput"><span class="identifier">p</span></code> is a function, and cannot itself be used
        as a parser; it must be called. In the table below:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            each entry is a global object usable directly in your parsers, unless
            otherwise noted;
          </li>
<li class="listitem">
            "code point" is used to refer to the elements of the input
            range, which assumes that the parse is being done in the Unicode-aware
            code path (if the parse is being done in the non-Unicode code path, read
            "code point" as "<code class="computeroutput"><span class="keyword">char</span></code>");
          </li>
<li class="listitem">
            <span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><code class="computeroutput"><span class="special">()</span></code>
            is a notional macro that expands to the resolution of parse argument
            or evaluation of a parse predicate (see <a class="link" href="the_parsers_and_their_uses.html" title="The Parsers And Their Uses">The
            Parsers And Their Uses</a>);
          </li>
<li class="listitem">
            "<code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">true</span></code>"
            is a shorthand notation for "<code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span></code> is contextually convertible to <code class="computeroutput"><span class="keyword">bool</span></code> and <code class="computeroutput"><span class="keyword">true</span></code>";
            likewise for <code class="computeroutput"><span class="keyword">false</span></code>;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">c</span></code> is a character of type
            <code class="computeroutput"><span class="keyword">char</span></code>, <code class="computeroutput"><span class="identifier">char8_t</span></code>,
            or <code class="computeroutput"><span class="keyword">char32_t</span></code>;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">str</span></code> is a string literal
            of type <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span><span class="special">[]</span></code>, <code class="computeroutput"><span class="identifier">char8_t</span>
            <span class="keyword">const</span> <span class="special">[]</span></code>,
            or <code class="computeroutput"><span class="keyword">char32_t</span> <span class="keyword">const</span>
            <span class="special">[]</span></code>;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">pred</span></code> is a parse predicate;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">arg0</span></code>, <code class="computeroutput"><span class="identifier">arg1</span></code>,
            <code class="computeroutput"><span class="identifier">arg2</span></code>, ... are parse arguments;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">a</span></code> is a semantic action;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">r</span></code> is an object whose
            type models <code class="computeroutput"><span class="identifier">parsable_range</span></code>;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">p</span></code>, <code class="computeroutput"><span class="identifier">p1</span></code>,
            <code class="computeroutput"><span class="identifier">p2</span></code>, ... are parsers;
            and
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">escapes</span></code> is a <code class="computeroutput"><a class="link" href="../../boost/parser/symbols.html" title="Struct template symbols">symbols&lt;T&gt;</a></code> object, where <code class="computeroutput"><span class="identifier">T</span></code> is <code class="computeroutput"><span class="keyword">char</span></code>
            or <code class="computeroutput"><span class="keyword">char32_t</span></code>.
          </li>
</ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          The definition of <code class="computeroutput"><span class="identifier">parsable_range</span></code>
          is:
        </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">concept</span> <span class="identifier">parsable_range</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ranges</span><span class="special">::</span><span class="identifier">forward_range</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span>
                          <span class="identifier">code_unit</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ranges</span><span class="special">::</span><span class="identifier">range_value_t</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;)</span> <span class="special">||</span>
                         <span class="identifier">detail</span><span class="special">::</span><span class="identifier">is_tokens_view_v</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;;</span>
</pre>
<p>
        </p>
</td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Some of the parsers in this table consume no input. All parsers consume
          the input they match unless otherwise stated in the table below.
        </p></td></tr>
</table></div>
<div class="table">
<a name="boost_parser.tutorial.the_parsers_and_their_uses.t0"></a><p class="title"><b>Table 1.6. Parsers and Their Semantics</b></p>
<div class="table-contents"><table class="table" summary="Parsers and Their Semantics">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Parser
                </p>
              </th>
<th>
                <p>
                  Semantics
                </p>
              </th>
<th>
                <p>
                  Attribute Type
                </p>
              </th>
<th>
                <p>
                  Notes
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches <span class="emphasis"><em>epsilon</em></span>, the empty string. Always
                  matches, and consumes no input.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  Matching <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  an unlimited number of times creates an infinite loop, which is
                  undefined behavior in C++. Boost.Parser will assert in debug mode
                  when it encounters <code class="computeroutput"><span class="special">*</span><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>,
                  <code class="computeroutput"><span class="special">+</span><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>, etc
                  (this applies to unconditional <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code> only).
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Fails to match the input if <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">false</span></code>. Otherwise, the semantics
                  are those of <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ws.html" title="Global ws">ws</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single whitespace code point (see note), according to
                  the Unicode White_Space property.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  For more info, see the <a href="https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt" target="_top">Unicode
                  properties</a>. <code class="computeroutput"><a class="link" href="../../boost/parser/ws.html" title="Global ws">ws</a></code> may consume one
                  code point or two. It only consumes two code points when it matches
                  <code class="computeroutput"><span class="string">"\r\n"</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eol.html" title="Global eol">eol</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single newline (see note), following the "hard"
                  line breaks in the Unicode line breaking algorithm.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  For more info, see the <a href="https://unicode.org/reports/tr14" target="_top">Unicode
                  Line Breaking Algorithm</a>. <code class="computeroutput"><a class="link" href="../../boost/parser/eol.html" title="Global eol">eol</a></code> may consume
                  one code point or two. It only consumes two code points when it
                  matches <code class="computeroutput"><span class="string">"\r\n"</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eoi.html" title="Global eoi">eoi</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches only at the end of input, and consumes no input.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/attr.html" title="Function template attr">attr</a></code><code class="computeroutput"><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Always matches, and consumes no input. Generates the attribute
                  <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">decltype</span><span class="special">(</span><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">))</span></code>.
                </p>
              </td>
<td>
                <p>
                  An important use case for <code class="computeroutput"><a class="link" href="../../boost/parser/attribute.html" title="Struct template attribute">attribute</a></code>
                  is to provide a default attribute value as a trailing alternative.
                  For instance, an <span class="bold"><strong>optional</strong></span> comma-delmited
                  list is: <code class="computeroutput"><span class="identifier">int_</span> <span class="special">%</span> <span class="char">','</span> <span class="special">|</span> <span class="identifier">attr</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;)</span></code>. Without the "<code class="computeroutput"><span class="special">|</span> <span class="identifier">attr</span><span class="special">(...)</span></code>", at least one <code class="computeroutput"><span class="identifier">int_</span></code> match would be required.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches any single code point.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See <a class="link" href="attribute_generation.html" title="Attribute Generation">Attribute
                  Generation</a>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the code point <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See <a class="link" href="attribute_generation.html" title="Attribute Generation">Attribute
                  Generation</a>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches the next code point <code class="computeroutput"><span class="identifier">n</span></code>
                  in the input, if <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span> <span class="special">&lt;=</span>
                  <span class="identifier">n</span> <span class="special">&amp;&amp;</span>
                  <span class="identifier">n</span> <span class="special">&lt;=</span>
                  <span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See <a class="link" href="attribute_generation.html" title="Attribute Generation">Attribute
                  Generation</a>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a><span class="special">(</span><span class="identifier">r</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches the next code point <code class="computeroutput"><span class="identifier">n</span></code>
                  in the input, if <code class="computeroutput"><span class="identifier">n</span></code>
                  is one of the code points in <code class="computeroutput"><span class="identifier">r</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See <a class="link" href="attribute_generation.html" title="Attribute Generation">Attribute
                  Generation</a>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">r</span></code> is taken to be
                  in a UTF encoding. The exact UTF used depends on <code class="computeroutput"><span class="identifier">r</span></code>'s element type. If you do not
                  pass UTF encoded ranges for <code class="computeroutput"><span class="identifier">r</span></code>,
                  the behavior of <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code> is undefined.
                  Note that ASCII is a subset of UTF-8, so ASCII is fine. EBCDIC
                  is not. <code class="computeroutput"><span class="identifier">r</span></code> is not
                  copied; a reference to it is taken. The lifetime of <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a><span class="special">(</span><span class="identifier">r</span><span class="special">)</span></code> must be within the lifetime of
                  <code class="computeroutput"><span class="identifier">r</span></code>. This overload
                  of <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>
                  does <span class="bold"><strong>not</strong></span> take parse arguments.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/cp.html" title="Global cp">cp</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">char32_t</span></code>
                </p>
              </td>
<td>
                <p>
                  Similar to <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, but with
                  a fixed <code class="computeroutput"><span class="keyword">char32_t</span></code> attribute
                  type; <code class="computeroutput"><a class="link" href="../../boost/parser/cp.html" title="Global cp">cp</a></code>
                  has all the same call operator overloads as <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, though they
                  are not repeated here, for brevity.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/cu.html" title="Global cu">cu</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">char</span></code>
                </p>
              </td>
<td>
                <p>
                  Similar to <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, but with
                  a fixed <code class="computeroutput"><span class="keyword">char</span></code> attribute
                  type; <code class="computeroutput"><a class="link" href="../../boost/parser/cu.html" title="Global cu">cu</a></code>
                  has all the same call operator overloads as <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, though they
                  are not repeated here, for brevity. Even though the name "<code class="computeroutput"><span class="identifier">cu</span></code>" suggests that this parser
                  match at the code unit level, it does not. The name refers to the
                  attribute type generated, much like the names <code class="computeroutput"><a class="link" href="../../boost/parser/int_.html" title="Global int_">int_</a></code> versus <code class="computeroutput"><a class="link" href="../../boost/parser/uint_.html" title="Global uint_">uint_</a></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/blank.html" title="Global blank">blank</a></code>
                </p>
              </td>
<td>
                <p>
                  Equivalent to <code class="computeroutput"><a class="link" href="../../boost/parser/ws.html" title="Global ws">ws</a> <span class="special">-</span>
                  <a class="link" href="../../boost/parser/eol.html" title="Global eol">eol</a></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/control.html" title="Global control">control</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single control-character code point.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/digit.html" title="Global digit">digit</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single decimal digit code point.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/punct.html" title="Global punct">punct</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single punctuation code point.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/hex_digit.html" title="Global hex_digit">hex_digit</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single hexidecimal digit code point.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/lower.html" title="Global lower">lower</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single lower-case code point.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/upper.html" title="Global upper">upper</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single upper-case code point.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/lit_id9.html" title="Function lit">lit</a></code><code class="computeroutput"><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the given code point <code class="computeroutput"><span class="identifier">c</span></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/lit_id9.html" title="Function lit">lit()</a></code> does <span class="bold"><strong>not</strong></span> take parse arguments.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">c_l</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the given code point <code class="computeroutput"><span class="identifier">c</span></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  This is a <a href="https://en.cppreference.com/w/cpp/language/user_literal" target="_top">UDL</a>
                  that represents <code class="computeroutput"><a class="link" href="../../boost/parser/lit_id9.html" title="Function lit">lit</a><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>,
                  for example <code class="computeroutput"><span class="char">'F'</span><span class="identifier">_l</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/lit_id9.html" title="Function lit">lit</a></code><code class="computeroutput"><span class="special">(</span><span class="identifier">r</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the given string <code class="computeroutput"><span class="identifier">r</span></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/lit_id9.html" title="Function lit">lit()</a></code> does <span class="bold"><strong>not</strong></span> take parse arguments.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">str_l</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the given string <code class="computeroutput"><span class="identifier">str</span></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  This is a <a href="https://en.cppreference.com/w/cpp/language/user_literal" target="_top">UDL</a>
                  that represents <code class="computeroutput"><a class="link" href="../../boost/parser/lit_id9.html" title="Function lit">lit</a><span class="special">(</span><span class="identifier">s</span><span class="special">)</span></code>,
                  for example <code class="computeroutput"><span class="string">"a string"</span><span class="identifier">_l</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/string.html" title="Function template string">string</a><span class="special">(</span><span class="identifier">r</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly <code class="computeroutput"><span class="identifier">r</span></code>,
                  and generates the match as an attribute.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/string.html" title="Function template string">string()</a></code> does <span class="bold"><strong>not</strong></span> take parse arguments.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">str_p</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly <code class="computeroutput"><span class="identifier">str</span></code>,
                  and generates the match as an attribute.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
                </p>
              </td>
<td>
                <p>
                  This is a <a href="https://en.cppreference.com/w/cpp/language/user_literal" target="_top">UDL</a>
                  that represents <code class="computeroutput"><a class="link" href="../../boost/parser/string.html" title="Function template string">string</a><span class="special">(</span><span class="identifier">s</span><span class="special">)</span></code>, for example <code class="computeroutput"><span class="string">"a
                  string"</span><span class="identifier">_p</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/bool_.html" title="Global bool_">bool_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches <code class="computeroutput"><span class="string">"true"</span></code>
                  or <code class="computeroutput"><span class="string">"false"</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">bool</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/bin.html" title="Global bin">bin</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a binary unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
                <p>
                  For example, <code class="computeroutput"><a class="link" href="../../boost/parser/bin.html" title="Global bin">bin</a></code> would match
                  <code class="computeroutput"><span class="string">"101"</span></code>, and
                  generate an attribute of <code class="computeroutput"><span class="number">5u</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/bin.html" title="Global bin">bin</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the binary unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/oct.html" title="Global oct">oct</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an octal unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
                <p>
                  For example, <code class="computeroutput"><a class="link" href="../../boost/parser/oct.html" title="Global oct">oct</a></code> would match
                  <code class="computeroutput"><span class="string">"31"</span></code>, and
                  generate an attribute of <code class="computeroutput"><span class="number">25u</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/oct.html" title="Global oct">oct</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the octal unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/hex.html" title="Global hex">hex</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a hexadecimal unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
                <p>
                  For example, <code class="computeroutput"><a class="link" href="../../boost/parser/hex.html" title="Global hex">hex</a></code> would match
                  <code class="computeroutput"><span class="string">"ff"</span></code>, and
                  generate an attribute of <code class="computeroutput"><span class="number">255u</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/hex.html" title="Global hex">hex</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the hexadecimal unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ushort_.html" title="Global ushort_">ushort_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">short</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ushort_.html" title="Global ushort_">ushort_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">short</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/uint_.html" title="Global uint_">uint_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/uint_.html" title="Global uint_">uint_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ulong_.html" title="Global ulong_">ulong_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ulong_.html" title="Global ulong_">ulong_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ulong_long.html" title="Global ulong_long">ulong_long</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span>
                  <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ulong_long.html" title="Global ulong_long">ulong_long</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span>
                  <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/short_.html" title="Global short_">short_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a signed integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">short</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/short_.html" title="Global short_">short_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the signed integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">short</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/int_.html" title="Global int_">int_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a signed integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/int_.html" title="Global int_">int_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the signed integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/long_.html" title="Global long_">long_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a signed integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/long_.html" title="Global long_">long_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the signed integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/long_long.html" title="Global long_long">long_long</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a signed integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/long_long.html" title="Global long_long">long_long</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the signed integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/float_.html" title="Global float_">float_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a floating-point number. <code class="computeroutput"><a class="link" href="../../boost/parser/float_.html" title="Global float_">float_</a></code> uses parsing
                  implementation details from <a href="https://www.boost.org/doc/libs/release/libs/spirit" target="_top">Boost.Spirit</a>.
                  The specifics of what formats are accepted can be found in their
                  <a href="https://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/numeric/real.html" target="_top">real
                  number parsers</a>. Note that only the default <code class="computeroutput"><span class="identifier">RealPolicies</span></code> is supported by
                  <code class="computeroutput"><a class="link" href="../../boost/parser/float_.html" title="Global float_">float_</a></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">float</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/double_.html" title="Global double_">double_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a floating-point number. <code class="computeroutput"><a class="link" href="../../boost/parser/double_.html" title="Global double_">double_</a></code> uses parsing
                  implementation details from <a href="https://www.boost.org/doc/libs/release/libs/spirit" target="_top">Boost.Spirit</a>.
                  The specifics of what formats are accepted can be found in their
                  <a href="https://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/numeric/real.html" target="_top">real
                  number parsers</a>. Note that only the default <code class="computeroutput"><span class="identifier">RealPolicies</span></code> is supported by
                  <code class="computeroutput"><a class="link" href="../../boost/parser/double_.html" title="Global double_">double_</a></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">double</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/repeat_id13.html" title="Function template repeat">repeat</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)[</span><span class="identifier">p</span><span class="special">]</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches iff <code class="computeroutput"><span class="identifier">p</span></code> matches
                  exactly <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code> times.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> if <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)</span></code> is <code class="computeroutput"><span class="keyword">char</span></code>
                  or <code class="computeroutput"><span class="keyword">char32_t</span></code>, otherwise
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  The special value <code class="computeroutput"><a class="link" href="../../boost/parser/Inf.html" title="Global Inf">Inf</a></code> may be used;
                  it indicates unlimited repetition. <code class="computeroutput"><span class="keyword">decltype</span><span class="special">(</span><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">))</span></code> must be implicitly convertible
                  to <code class="computeroutput"><span class="identifier">int64_t</span></code>. Matching
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  an unlimited number of times creates an infinite loop, which is
                  undefined behavior in C++. Boost.Parser will assert in debug mode
                  when it encounters <code class="computeroutput"><a class="link" href="../../boost/parser/repeat_id13.html" title="Function template repeat">repeat</a><span class="special">(</span><a class="link" href="../../boost/parser/Inf.html" title="Global Inf">Inf</a><span class="special">)[</span><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a><span class="special">]</span></code> (this applies to unconditional
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  only).
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/repeat_id13.html" title="Function template repeat">repeat</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)[</span><span class="identifier">p</span><span class="special">]</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches iff <code class="computeroutput"><span class="identifier">p</span></code> matches
                  between <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code> and <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span></code> times, inclusively.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> if <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)</span></code> is <code class="computeroutput"><span class="keyword">char</span></code>
                  or <code class="computeroutput"><span class="keyword">char32_t</span></code>, otherwise
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  The special value <code class="computeroutput"><a class="link" href="../../boost/parser/Inf.html" title="Global Inf">Inf</a></code> may be used
                  for the upper bound; it indicates unlimited repetition. <code class="computeroutput"><span class="keyword">decltype</span><span class="special">(</span><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">))</span></code> and <code class="computeroutput"><span class="keyword">decltype</span><span class="special">(</span><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg1</span><span class="special">))</span></code> each must be implicitly convertible
                  to <code class="computeroutput"><span class="identifier">int64_t</span></code>. Matching
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  an unlimited number of times creates an infinite loop, which is
                  undefined behavior in C++. Boost.Parser will assert in debug mode
                  when it encounters <code class="computeroutput"><a class="link" href="../../boost/parser/repeat_id13.html" title="Function template repeat">repeat</a><span class="special">(</span><span class="identifier">n</span><span class="special">,</span> <a class="link" href="../../boost/parser/Inf.html" title="Global Inf">Inf</a><span class="special">)[</span><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a><span class="special">]</span></code> (this applies to unconditional
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  only).
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/if_.html" title="Function template if_">if_</a><span class="special">(</span><span class="identifier">pred</span><span class="special">)[</span><span class="identifier">p</span><span class="special">]</span></code>
                </p>
              </td>
<td>
                <p>
                  Equivalent to <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span>
                  <span class="special">&gt;&gt;</span> <span class="identifier">p</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  It is an error to write <code class="computeroutput"><a class="link" href="../../boost/parser/if_.html" title="Function template if_">if_</a><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span></code>.
                  That is, it is an error to omit the conditionally matched parser
                  <code class="computeroutput"><span class="identifier">p</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/switch_.html" title="Function template switch_">switch_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)(</span><span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">p1</span><span class="special">)(</span><span class="identifier">arg2</span><span class="special">,</span> <span class="identifier">p2</span><span class="special">)</span> <span class="special">...</span></code>
                </p>
              </td>
<td>
                <p>
                  Equivalent to <code class="computeroutput"><span class="identifier">p1</span></code>
                  when <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span> <span class="special">==</span> <span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span></code>, <code class="computeroutput"><span class="identifier">p2</span></code>
                  when <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span> <span class="special">==</span> <span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg2</span><span class="special">)</span></code>, etc. If there is such no <code class="computeroutput"><span class="identifier">argN</span></code>, the behavior of <code class="computeroutput"><a class="link" href="../../boost/parser/switch_.html" title="Function template switch_">switch_()</a></code> is undefined.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p1</span><span class="special">),</span> <span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p2</span><span class="special">),</span> <span class="special">...&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  It is an error to write <code class="computeroutput"><a class="link" href="../../boost/parser/switch_.html" title="Function template switch_">switch_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>. That is, it is an error to omit
                  the conditionally matched parsers <code class="computeroutput"><span class="identifier">p1</span></code>,
                  <code class="computeroutput"><span class="identifier">p2</span></code>, ....
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/symbols.html" title="Struct template symbols">symbols&lt;T&gt;</a></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/symbols.html" title="Struct template symbols">symbols</a></code>
                  is an associative container of key, value pairs. Each key is a
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> and each value has type
                  <code class="computeroutput"><span class="identifier">T</span></code>. In the Unicode
                  parsing path, the strings are considered to be UTF-8 encoded; in
                  the non-Unicode path, no encoding is assumed. <code class="computeroutput"><a class="link" href="../../boost/parser/symbols.html" title="Struct template symbols">symbols</a></code> Matches the
                  longest prefix <code class="computeroutput"><span class="identifier">pre</span></code>
                  of the input that is equal to one of the keys <code class="computeroutput"><span class="identifier">k</span></code>.
                  If the length <code class="computeroutput"><span class="identifier">len</span></code>
                  of <code class="computeroutput"><span class="identifier">pre</span></code> is zero,
                  and there is no zero-length key, it does not match the input. If
                  <code class="computeroutput"><span class="identifier">len</span></code> is positive,
                  the generated attribute is the value associated with <code class="computeroutput"><span class="identifier">k</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">T</span></code>
                </p>
              </td>
<td>
                <p>
                  Unlike the other entries in this table, <code class="computeroutput"><a class="link" href="../../boost/parser/symbols.html" title="Struct template symbols">symbols</a></code> is a type,
                  not an object.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/quoted_string.html" title="Global quoted_string">quoted_string</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches <code class="computeroutput"><span class="char">'"'</span></code>, followed
                  by zero or more characters, followed by <code class="computeroutput"><span class="char">'"'</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
                </p>
              </td>
<td>
                <p>
                  The result does not include the quotes. A quote within the string
                  can be written by escaping it with a backslash. A backslash within
                  the string can be written by writing two consecutive backslashes.
                  Any other use of a backslash will fail the parse. Skipping is disabled
                  while parsing the entire string, as if using <code class="computeroutput"><a class="link" href="../../boost/parser/lexeme.html" title="Global lexeme">lexeme[]</a></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/quoted_string.html" title="Global quoted_string">quoted_string</a><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches <code class="computeroutput"><span class="identifier">c</span></code>, followed
                  by zero or more characters, followed by <code class="computeroutput"><span class="identifier">c</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
                </p>
              </td>
<td>
                <p>
                  The result does not include the <code class="computeroutput"><span class="identifier">c</span></code>
                  quotes. A <code class="computeroutput"><span class="identifier">c</span></code> within
                  the string can be written by escaping it with a backslash. A backslash
                  within the string can be written by writing two consecutive backslashes.
                  Any other use of a backslash will fail the parse. Skipping is disabled
                  while parsing the entire string, as if using <code class="computeroutput"><a class="link" href="../../boost/parser/lexeme.html" title="Global lexeme">lexeme[]</a></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/quoted_string.html" title="Global quoted_string">quoted_string</a><span class="special">(</span><span class="identifier">r</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches some character <code class="computeroutput"><span class="identifier">Q</span></code>
                  in <code class="computeroutput"><span class="identifier">r</span></code>, followed
                  by zero or more characters, followed by <code class="computeroutput"><span class="identifier">Q</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
                </p>
              </td>
<td>
                <p>
                  The result does not include the <code class="computeroutput"><span class="identifier">Q</span></code>
                  quotes. A <code class="computeroutput"><span class="identifier">Q</span></code> within
                  the string can be written by escaping it with a backslash. A backslash
                  within the string can be written by writing two consecutive backslashes.
                  Any other use of a backslash will fail the parse. Skipping is disabled
                  while parsing the entire string, as if using <code class="computeroutput"><a class="link" href="../../boost/parser/lexeme.html" title="Global lexeme">lexeme[]</a></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/quoted_string.html" title="Global quoted_string">quoted_string</a><span class="special">(</span><span class="identifier">c</span><span class="special">,</span> <span class="identifier">symbols</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches <code class="computeroutput"><span class="identifier">c</span></code>, followed
                  by zero or more characters, followed by <code class="computeroutput"><span class="identifier">c</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
                </p>
              </td>
<td>
                <p>
                  The result does not include the <code class="computeroutput"><span class="identifier">c</span></code>
                  quotes. A <code class="computeroutput"><span class="identifier">c</span></code> within
                  the string can be written by escaping it with a backslash. A backslash
                  within the string can be written by writing two consecutive backslashes.
                  A backslash followed by a successful match using <code class="computeroutput"><span class="identifier">symbols</span></code> will be interpreted as
                  the corresponding value produced by <code class="computeroutput"><span class="identifier">symbols</span></code>.
                  Any other use of a backslash will fail the parse. Skipping is disabled
                  while parsing the entire string, as if using <code class="computeroutput"><a class="link" href="../../boost/parser/lexeme.html" title="Global lexeme">lexeme[]</a></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/quoted_string.html" title="Global quoted_string">quoted_string</a><span class="special">(</span><span class="identifier">r</span><span class="special">,</span> <span class="identifier">symbols</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches some character <code class="computeroutput"><span class="identifier">Q</span></code>
                  in <code class="computeroutput"><span class="identifier">r</span></code>, followed
                  by zero or more characters, followed by <code class="computeroutput"><span class="identifier">Q</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
                </p>
              </td>
<td>
                <p>
                  The result does not include the <code class="computeroutput"><span class="identifier">Q</span></code>
                  quotes. A <code class="computeroutput"><span class="identifier">Q</span></code> within
                  the string can be written by escaping it with a backslash. A backslash
                  within the string can be written by writing two consecutive backslashes.
                  A backslash followed by a successful match using <code class="computeroutput"><span class="identifier">symbols</span></code> will be interpreted as
                  the corresponding value produced by <code class="computeroutput"><span class="identifier">symbols</span></code>.
                  Any other use of a backslash will fail the parse. Skipping is disabled
                  while parsing the entire string, as if using <code class="computeroutput"><a class="link" href="../../boost/parser/lexeme.html" title="Global lexeme">lexeme[]</a></code>.
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
          All the character parsers, like <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, <code class="computeroutput"><a class="link" href="../../boost/parser/cp.html" title="Global cp">cp</a></code> and <code class="computeroutput"><a class="link" href="../../boost/parser/cu.html" title="Global cu">cu</a></code> produce either <code class="computeroutput"><span class="keyword">char</span></code> or <code class="computeroutput"><span class="keyword">char32_t</span></code>
          attributes. So when you see "<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
          if <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)</span></code> is
          <code class="computeroutput"><span class="keyword">char</span></code> or <code class="computeroutput"><span class="keyword">char32_t</span></code>,
          otherwise <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)&gt;</span></code>"
          in the table above, that effectively means that every sequences of character
          attributes get turned into a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>.
          The only time this does not happen is when you introduce your own rules
          with attributes using another character type (or use <code class="computeroutput"><a class="link" href="../../boost/parser/attribute.html" title="Struct template attribute">attribute</a></code> to do so).
        </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          A slightly more complete description of the attributes generated by these
          parsers is in a subsequent section. The attributes are repeated here so
          you can use see all the properties of the parsers in one place.
        </p></td></tr>
</table></div>
<p>
        If you have an integral type <code class="computeroutput"><span class="identifier">IntType</span></code>
        that is not covered by any of the Boost.Parser parsers, you can use a more
        verbose declaration to declare a parser for <code class="computeroutput"><span class="identifier">IntType</span></code>.
        If <code class="computeroutput"><span class="identifier">IntType</span></code> were unsigned,
        you would use <code class="computeroutput"><span class="identifier">uint_parser</span></code>.
        If it were signed, you would use <code class="computeroutput"><span class="identifier">int_parser</span></code>.
        For example:
      </p>
<pre class="programlisting"><span class="keyword">constexpr</span> <span class="identifier">parser_interface</span><span class="special">&lt;</span><span class="identifier">int_parser</span><span class="special">&lt;</span><span class="identifier">IntType</span><span class="special">&gt;&gt;</span> <span class="identifier">hex_int</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">uint_parser</span></code> and <code class="computeroutput"><span class="identifier">int_parser</span></code> accept three more non-type template
        parameters after the type parameter. They are <code class="computeroutput"><span class="identifier">Radix</span></code>,
        <code class="computeroutput"><span class="identifier">MinDigits</span></code>, and <code class="computeroutput"><span class="identifier">MaxDigits</span></code>. <code class="computeroutput"><span class="identifier">Radix</span></code>
        defaults to <code class="computeroutput"><span class="number">10</span></code>, <code class="computeroutput"><span class="identifier">MinDigits</span></code> to <code class="computeroutput"><span class="number">1</span></code>,
        and <code class="computeroutput"><span class="identifier">MaxDigits</span></code> to <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>, which is
        a sentinel value meaning that there is no max number of digits.
      </p>
<p>
        So, if you wanted to parse exactly eight hexadecimal digits in a row in order
        to recognize Unicode character literals like C++ has (e.g. <code class="computeroutput"><span class="special">\</span><span class="identifier">Udeadbeef</span></code>),
        you could use this parser for the digits at the end:
      </p>
<pre class="programlisting"><span class="keyword">constexpr</span> <span class="identifier">parser_interface</span><span class="special">&lt;</span><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span> <span class="keyword">int</span><span class="special">,</span> <span class="number">16</span><span class="special">,</span> <span class="number">8</span><span class="special">,</span> <span class="number">8</span><span class="special">&gt;&gt;</span> <span class="identifier">hex_int</span><span class="special">;</span>
</pre>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="mutable_symbol_tables.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="directives.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
