<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>More About Rules</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="the__parse____api.html" title="The parse() API">
<link rel="next" href="algorithms_and_views_that_use_parsers.html" title="Algorithms and Views That Use Parsers">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="the__parse____api.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="algorithms_and_views_that_use_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.more_about_rules"></a><a class="link" href="more_about_rules.html" title="More About Rules">More
      About Rules</a>
</h3></div></div></div>
<p>
        In the earlier page about <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code> (<a class="link" href="rule_parsers.html" title="Rule Parsers">Rule
        Parsers</a>), I described <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code> as being analogous to
        functions. <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>
        are, at base, organizational. Here are the common use cases for <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>.
        Use a <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>
        if you want to:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            fix the attribute type produced by a parser to something other than the
            default;
          </li>
<li class="listitem">
            create a parser that produces useful diagnostic text;
          </li>
<li class="listitem">
            create a recursive rule (more on this below);
          </li>
<li class="listitem">
            create a set of mutually-recursive parsers;
          </li>
<li class="listitem">
            do callback parsing.
          </li>
</ul></div>
<p>
        Let's look at the use cases in detail.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h0"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.fixing_the_attribute_type"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.fixing_the_attribute_type">Fixing
        the attribute type</a>
      </h5>
<p>
        We saw in the previous section how <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32501.html" title="Function template parse">parse()</a></code>
        is flexible in what types it will accept as attribute out-parameters. Here's
        another example.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="keyword">int</span> <span class="special">%</span> <span class="char">','</span><span class="special">,</span> <span class="identifier">result</span><span class="special">);</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">result</span></code> can be one of many
        different types. It could be <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>.
        It could be <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">&gt;</span></code>. It could be a lot of things. Often,
        this is a very useful property; if you had to rewrite all of your parser
        logic because you changed the desired container in some part of your attribute
        from a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code> to a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span></code>,
        that would be annoying. However, that flexibility comes at the cost of type
        checking. If you want to write a parser that <span class="bold"><strong>always</strong></span>
        produces exactly a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">unsigned</span> <span class="keyword">int</span><span class="special">&gt;</span></code> <span class="bold"><strong>and no other type</strong></span>,
        you also probably want a compilation error if you accidentally pass that
        parser a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">unsigned</span> <span class="keyword">int</span><span class="special">&gt;</span></code> attribute instead. There is no way with
        a plain parser to enforce that its attribute type may only ever be a single,
        fixed type.
      </p>
<p>
        Fortunately, <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>
        allow you to write a parser that has a fixed attribute type. Every rule has
        a specific attribute type, provided as a template parameter. If one is not
        specified, the rule has no attribute. The fact that the attribute is a specific
        type allows you to remove attribute flexibility. For instance, say we have
        a rule defined like this:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">doubles</span> <span class="special">=</span> <span class="string">"doubles"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">doubles_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span><span class="special">;</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">doubles</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        You can then use it in a call to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32501.html" title="Function template parse">parse()</a></code>,
        and <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32501.html" title="Function template parse">parse()</a></code> will return a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span></code>:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        If you call <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32501.html" title="Function template parse">parse()</a></code> with an attribute out-parameter,
        it must be exactly <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">vec_result</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">,</span> <span class="identifier">vec_result</span><span class="special">);</span> <span class="comment">// Ok.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">deque_result</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">,</span> <span class="identifier">deque_result</span><span class="special">);</span> <span class="comment">// Ill-formed!</span>
</pre>
<p>
        If we wanted to use a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code> as the attribute type of our rule:
      </p>
<pre class="programlisting"><span class="comment">// Attribute changed to std::deque&lt;double&gt;.</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">doubles</span> <span class="special">=</span> <span class="string">"doubles"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">doubles_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span><span class="special">;</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">doubles</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">deque_result</span><span class="special">;</span>
    <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">,</span> <span class="identifier">deque_result</span><span class="special">);</span> <span class="comment">// Ok.</span>
<span class="special">}</span>
</pre>
<p>
        The take-away here is that the attribute flexibility is still available,
        but only <span class="bold"><strong>within</strong></span> the rule — the parser
        <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span></code> can parse into a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code> or a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>, but the rule <code class="computeroutput"><span class="identifier">doubles</span></code>
        must parse into only the exact attribute it was declared to generate.
      </p>
<p>
        The reason for this is that, inside the rule parsing implementation, there
        is code something like this:
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="identifier">attr_t</span> <span class="special">=</span> <span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">doubles_def</span><span class="special">);</span>
<span class="identifier">attr_t</span> <span class="identifier">attr</span><span class="special">;</span>
<span class="identifier">parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">parser</span><span class="special">,</span> <span class="identifier">attr</span><span class="special">);</span>
<span class="identifier">attribute_out_param</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">attr</span><span class="special">);</span>
</pre>
<p>
        Where <code class="computeroutput"><span class="identifier">attribute_out_param</span></code>
        is the attribute out-parameter we pass to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32501.html" title="Function template parse">parse()</a></code>.
        If that final move assignment is ill-formed, the call to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32501.html" title="Function template parse">parse()</a></code>
        is too.
      </p>
<p>
        You can also use rules to exploit attribute flexibility. Even though a rule
        reduces the flexibility of attributes it can generate, the fact that it is
        so easy to write a new rule means that we can use rules themselves to get
        the attribute flexibility we want across our code:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="comment">// We only need to write the definition once...</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">generic_doubles_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">vec_doubles</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">vec_doubles</span> <span class="special">=</span> <span class="string">"vec_doubles"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">vec_doubles_def</span> <span class="special">=</span> <span class="identifier">generic_doubles_def</span><span class="special">;</span> <span class="comment">// ... and re-use it,</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">vec_doubles</span><span class="special">);</span>

<span class="comment">// Attribute changed to std::deque&lt;double&gt;.</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">deque_doubles</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">deque_doubles</span> <span class="special">=</span> <span class="string">"deque_doubles"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">deque_doubles_def</span> <span class="special">=</span> <span class="identifier">generic_doubles_def</span><span class="special">;</span> <span class="comment">// ... and re-use it again.</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">deque_doubles</span><span class="special">);</span>
</pre>
<p>
        Now we have one of each, and we did not have to copy any parsing logic that
        would have to be maintained in two places.
      </p>
<p>
        Sometimes, you need to create a rule to enforce a certain attribute type,
        but the rule's attribute is not constructible from its parser's attribute.
        When that happens, you'll need to write a semantic action.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">type_t</span>
<span class="special">{</span>
    <span class="identifier">type_t</span><span class="special">()</span> <span class="special">=</span> <span class="keyword">default</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">type_t</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">x_</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">{}</span>
    <span class="comment">// etc.</span>

    <span class="keyword">double</span> <span class="identifier">x_</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="identifier">doubles_to_type</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>
    <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">type_t</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)[</span><span class="number">0</span><span class="identifier">_c</span><span class="special">]</span> <span class="special">*</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)[</span><span class="number">1</span><span class="identifier">_c</span><span class="special">]);</span>
<span class="special">};</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">type_tag</span><span class="special">,</span> <span class="identifier">type_t</span><span class="special">&gt;</span> <span class="identifier">type</span> <span class="special">=</span> <span class="string">"type"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">type_def</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span> <span class="special">&gt;&gt;</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span><span class="special">)[</span><span class="identifier">doubles_to_type</span><span class="special">];</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">type</span><span class="special">);</span>
</pre>
<p>
        For a rule <code class="computeroutput"><span class="identifier">R</span></code> and its parser
        <code class="computeroutput"><span class="identifier">P</span></code>, we do not need to write
        such a semantic action if:
      </p>
<p>
        - <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">R</span><span class="special">)</span></code> is an
        aggregate, and <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">P</span><span class="special">)</span></code>
        is a compatible tuple;
      </p>
<p>
        - <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">R</span><span class="special">)</span></code> is a
        tuple, and <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">P</span><span class="special">)</span></code> is a
        compatible aggregate;
      </p>
<p>
        - <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">R</span><span class="special">)</span></code> is a
        non-aggregate class type <code class="computeroutput"><span class="identifier">C</span></code>,
        and <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">P</span><span class="special">)</span></code> is a
        tuple whose elements can be used to construct <code class="computeroutput"><span class="identifier">C</span></code>;
        or
      </p>
<p>
        - <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">R</span><span class="special">)</span></code> and
        <code class="computeroutput"><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">P</span><span class="special">)</span></code> are
        compatible types.
      </p>
<p>
        The notion of "compatible" is defined in <a class="link" href="the__parse____api.html" title="The parse() API">The
        <code class="computeroutput"><span class="identifier">parse</span><span class="special">()</span></code>
        API</a>.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h1"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.creating_a_parser_for_better_diagnostics"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.creating_a_parser_for_better_diagnostics">Creating
        a parser for better diagnostics</a>
      </h5>
<p>
        Each <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>
        has associated diagnostic text that Boost.Parser can use for failures of
        that rule. This is useful when the parse reaches a parse failure at an expectation
        point (see <a class="link" href="backtracking.html#boost_parser__proposed_.tutorial.backtracking.expectation_points">Expectation
        points</a>). Let's say you have the following code defined somewhere.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">value_tag</span><span class="special">&gt;</span> <span class="identifier">value</span> <span class="special">=</span>
    <span class="string">"an integer, or a list of integers in braces"</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">ints</span> <span class="special">=</span> <span class="char">'{'</span> <span class="special">&gt;</span> <span class="special">(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span> <span class="special">&gt;</span> <span class="char">'}'</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">value_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">|</span> <span class="identifier">ints</span><span class="special">;</span>

<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span>
</pre>
<p>
        Notice the two expectation points. One before <code class="computeroutput"><span class="special">(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span></code>, one before
        the final <code class="computeroutput"><span class="char">'}'</span></code>. Later, you call
        parse in some input:
      </p>
<pre class="programlisting"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"{ 4, 5 a"</span><span class="special">,</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
</pre>
<p>
        This runs should of the second expectation point, and produces output like
        this:
      </p>
<pre class="programlisting">1:7: error: Expected '}' here:
{ 4, 5 a
       ^
</pre>
<p>
        That's a pretty good error message. Here's what it looks like if we violate
        the earlier expectation:
      </p>
<pre class="programlisting"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"{ }"</span><span class="special">,</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
</pre>
<pre class="programlisting">1:2: error: Expected an integer, or a list of integers in braces % ',' here:
{ }
  ^
</pre>
<p>
        Not nearly as nice. The problem is that the expectation is on <code class="computeroutput"><span class="special">(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span></code>.
        So, even thought we gave <code class="computeroutput"><span class="identifier">value</span></code>
        reasonable dianostic text, we put the text on the wrong thing. We can introduce
        a new rule to put the diagnstic text in the right place.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">value_tag</span><span class="special">&gt;</span> <span class="identifier">value</span> <span class="special">=</span>
    <span class="string">"an integer, or a list of integers in braces"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">comma_values_tag</span><span class="special">&gt;</span> <span class="identifier">comma_values</span> <span class="special">=</span>
    <span class="string">"a comma-delimited list of integers"</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">ints</span> <span class="special">=</span> <span class="char">'{'</span> <span class="special">&gt;</span> <span class="identifier">comma_values</span> <span class="special">&gt;</span> <span class="char">'}'</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">value_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">|</span> <span class="identifier">ints</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">comma_values_def</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">);</span>

<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">value</span><span class="special">,</span> <span class="identifier">comma_values</span><span class="special">);</span>
</pre>
<p>
        Now when we call <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"{ }"</span><span class="special">,</span>
        <span class="identifier">value</span><span class="special">,</span>
        <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">)</span></code> we
        get a much better message:
      </p>
<pre class="programlisting">1:2: error: Expected a comma-delimited list of integers here:
{ }
  ^
</pre>
<p>
        The <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>
        <code class="computeroutput"><span class="identifier">value</span></code> might be useful elsewhere
        in our code, perhaps in another parser. It's diagnostic text is appropriate
        for those other potential uses.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h2"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.recursive_rules"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.recursive_rules">Recursive
        rules</a>
      </h5>
<p>
        It's pretty common to see grammars that include recursive rules. Consider
        this EBNF rule for balanced parentheses:
      </p>
<pre class="programlisting">&lt;parens&gt; ::= "" | ( "(" &lt;parens&gt; ")" )
</pre>
<p>
        We can try to write this using Boost.Parser like this:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">parens</span> <span class="special">=</span> <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">parens</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>
</pre>
<p>
        We had to put the <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span></code> second, because Boost.Parser's parsing
        algorithm is greedy. Otherwise, it's just a straight transliteration. Unfortunately,
        it does not work. The code is ill-formed because you can't define a variable
        in terms of itself. Well you can, but nothing good comes of it. If we instead
        make the parser in terms of a forward-declared <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>, it works.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">parens_tag</span><span class="special">&gt;</span> <span class="identifier">parens</span> <span class="special">=</span> <span class="string">"matched parentheses"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">parens_def</span> <span class="special">=</span> <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">parens</span> <span class="special">&gt;</span> <span class="char">')'</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">parens</span><span class="special">);</span>
</pre>
<p>
        Later, if we use it to parse, it does what we want.
      </p>
<pre class="programlisting"><span class="identifier">assert</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"(((())))"</span><span class="special">,</span> <span class="identifier">parens</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">));</span>
</pre>
<p>
        When it fails, it even produces nice diagnostics.
      </p>
<pre class="programlisting"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"(((()))"</span><span class="special">,</span> <span class="identifier">parens</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
</pre>
<pre class="programlisting">1:7: error: Expected ')' here (end of input):
(((()))
       ^
</pre>
<p>
        Recursive <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>
        work differently from other parsers in one way: when re-entering the rule
        recursively, only the attribute variable (<code class="computeroutput"><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>
        in your semantic actions) is unique to that instance of the rule. All the
        other state of the uppermost instance of that rule is shared. This includes
        the value of the rule (<code class="computeroutput"><span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>),
        and the locals and parameters to the rule. In other words, <code class="computeroutput"><span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code> returns a reference to the <span class="bold"><strong>same
        object</strong></span> in every instance of a recursive <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>. This is because each
        instance of the rule needs a place to put the attribute it generates from
        its parse. However, we only want a single return value for the uppermost
        rule; if each instance had a separate value in <code class="computeroutput"><span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>,
        then it would be impossible to build up the result of a recursive rule step
        by step during in the evaluation of the recursive instantiations.
      </p>
<p>
        Also, consider this rule:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">ints_tag</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&gt;</span> <span class="identifier">ints</span> <span class="special">=</span> <span class="string">"ints"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">ints_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">&gt;&gt;</span> <span class="identifier">ints</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>
</pre>
<p>
        What is the default attribute type for ints_def? It sure looks like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&gt;</span></code>.
        Inside the evaluation of <code class="computeroutput"><span class="identifier">ints</span></code>,
        Boost.Parser must evaluate <code class="computeroutput"><span class="identifier">ints_def</span></code>,
        and then produce a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> —
        the return type of <code class="computeroutput"><span class="identifier">ints</span></code> —
        from it. How? How do you turn a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&gt;</span></code>
        into a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>? To
        a human, it seems obvious, but the metaprogramming that properly handles
        this simple example and the general case is certainly beyond me.
      </p>
<p>
        Boost.Parser has a specific semantic for what consitutes a recursive rule.
        Each rule has a tag type associated with it, and if Boost.Parser enters a
        rule with a certain tag <code class="computeroutput"><span class="identifier">Tag</span></code>,
        and the currently-evaluating rule (if there is one) also has the tag <code class="computeroutput"><span class="identifier">Tag</span></code>, then rule instance being entered is
        considered to be a recursion. No other situations are considered recursion.
        In particular, if you have rules <code class="computeroutput"><span class="identifier">Ra</span></code>
        and <code class="computeroutput"><span class="identifier">Rb</span></code>, and <code class="computeroutput"><span class="identifier">Ra</span></code> uses <code class="computeroutput"><span class="identifier">Rb</span></code>,
        which in turn used <code class="computeroutput"><span class="identifier">Ra</span></code>, the
        second use of <code class="computeroutput"><span class="identifier">Ra</span></code> is not considered
        recursion. <code class="computeroutput"><span class="identifier">Ra</span></code> and <code class="computeroutput"><span class="identifier">Rb</span></code> are of course mutually recursive, but
        neither is considered a "recursive rule" for purposes of getting
        a unique value, locals, and parameters.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h3"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.mutually_recursive_rules"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.mutually_recursive_rules">Mutually-recursive
        rules</a>
      </h5>
<p>
        One of the advantages of using rules is that you can declare all your rules
        up front and then use them immediately afterward. This lets you make rules
        that use each other without introducing cycles:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="comment">// Assume we have some polymorphic type that can be an object/dictionary,</span>
<span class="comment">// array, string, or int, called `value_type`.</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">string</span> <span class="special">=</span> <span class="string">"string"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">object_element</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">value_type</span><span class="special">&gt;&gt;</span> <span class="keyword">const</span> <span class="identifier">object_element</span> <span class="special">=</span> <span class="string">"object-element"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">object</span><span class="special">,</span> <span class="identifier">value_type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">object</span> <span class="special">=</span> <span class="string">"object"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">array</span><span class="special">,</span> <span class="identifier">value_type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">array</span> <span class="special">=</span> <span class="string">"array"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">value_tag</span><span class="special">,</span> <span class="identifier">value_type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">value</span> <span class="special">=</span> <span class="string">"value"</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">string_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">lexeme</span><span class="special">[</span><span class="char">'"'</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span> <span class="special">&gt;</span> <span class="char">'"'</span><span class="special">];</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">object_element_def</span> <span class="special">=</span> <span class="identifier">string</span> <span class="special">&gt;</span> <span class="char">':'</span> <span class="special">&gt;</span> <span class="identifier">value</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">object_def</span> <span class="special">=</span> <span class="char">'{'</span><span class="identifier">_l</span> <span class="special">&gt;&gt;</span> <span class="special">-(</span><span class="identifier">object_element</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span> <span class="special">&gt;</span> <span class="char">'}'</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">array_def</span> <span class="special">=</span> <span class="char">'['</span><span class="identifier">_l</span> <span class="special">&gt;&gt;</span> <span class="special">-(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span> <span class="special">&gt;</span> <span class="char">']'</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">value_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">bool_</span> <span class="special">|</span> <span class="identifier">string</span> <span class="special">|</span> <span class="identifier">array</span> <span class="special">|</span> <span class="identifier">object</span><span class="special">;</span>

<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">object_element</span><span class="special">,</span> <span class="identifier">object</span><span class="special">,</span> <span class="identifier">array</span><span class="special">,</span> <span class="identifier">value</span><span class="special">);</span>
</pre>
<p>
        Here we have a parser for a Javascript-value-like type <code class="computeroutput"><span class="identifier">value_type</span></code>.
        <code class="computeroutput"><span class="identifier">value_type</span></code> may be an array,
        which itself may contain other arrays, objects, strings, etc. Since we need
        to be able to parse objects within arrays and vice versa, we need each of
        those two parsers to be able to refer to each other.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h4"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.callback_parsing"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.callback_parsing">Callback
        parsing</a>
      </h5>
<p>
        Only <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>
        can be callback parsers, so if you want to get attributes supplied to you
        via callbacks instead of somewhere in the middle of a giant attribute that
        represents the whole parse result, you need to use <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>. See <a class="link" href="../extended_examples/parsing_json_with_callbacks.html" title="Parsing JSON With Callbacks">Parsing
        JSON With Callbacks</a> for an extended example of callback parsing.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h5"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.accessors_available_in_semantic_actions_on_rules"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.accessors_available_in_semantic_actions_on_rules">Accessors
        available in semantic actions on rules</a>
      </h5>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h6"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_">_val()</a>
      </h5>
<p>
        Inside all of a rule's semantic actions, the expression <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function _val">_val</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>
        is a reference to the attribute that the rule generates. This can be useful
        when you want subparsers to build up the attribute in a specific way:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ints</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&gt;</span> <span class="keyword">const</span> <span class="identifier">ints</span> <span class="special">=</span> <span class="string">"ints"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">twenty_zeros</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">resize</span><span class="special">(</span><span class="number">20</span><span class="special">,</span> <span class="number">0</span><span class="special">);</span> <span class="special">};</span>
<span class="keyword">auto</span> <span class="identifier">push_back</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">));</span> <span class="special">};</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">ints_def</span> <span class="special">=</span> <span class="string">"20-zeros"</span><span class="identifier">_l</span><span class="special">[</span><span class="identifier">twenty_zeros</span><span class="special">]</span> <span class="special">|</span> <span class="special">+</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span><span class="special">[</span><span class="identifier">push_back</span><span class="special">];</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">ints</span><span class="special">);</span>
</pre>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          That's just an example. It's almost always better to do things without
          using semantic actions. We could have instead written <code class="computeroutput"><span class="identifier">ints_def</span></code>
          as <code class="computeroutput"><span class="string">"20-zeros"</span> <span class="special">&gt;&gt;</span>
          <span class="identifier">bp</span><span class="special">::</span><span class="identifier">attr</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="number">20</span><span class="special">))</span> <span class="special">|</span>
          <span class="special">+</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span></code>,
          which has the same semantics, is a lot easier to read, and is a lot less
          code.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h7"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.locals"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.locals">Locals</a>
      </h5>
<p>
        The <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>
        template takes another template parameter we have not discussed yet. You
        can pass a third parameter <code class="computeroutput"><span class="identifier">LocalState</span></code>
        to <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>,
        which will be defaulted csontructed by the <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>, and made available within
        semantic actions used in the rule as <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>. This
        gives your rule some local state, if it needs it. The type of <code class="computeroutput"><span class="identifier">LocalState</span></code> can be anything regular. It
        could be a single value, a struct containing multiple values, or a tuple,
        among others.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">foo_locals</span>
<span class="special">{</span>
    <span class="keyword">char</span> <span class="identifier">first_value</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">foo</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">foo_locals</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">foo</span> <span class="special">=</span> <span class="string">"foo"</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="identifier">record_first</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_locals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">first_value</span> <span class="special">=</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span> <span class="special">}</span>
<span class="keyword">auto</span> <span class="identifier">check_against_first</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">char</span> <span class="keyword">const</span> <span class="identifier">first</span> <span class="special">=</span> <span class="identifier">_locals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">first_value</span><span class="special">;</span>
    <span class="keyword">char</span> <span class="keyword">const</span> <span class="identifier">attr</span> <span class="special">=</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">attr</span> <span class="special">==</span> <span class="identifier">first</span><span class="special">)</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="special">(</span><span class="keyword">int</span><span class="special">(</span><span class="identifier">first</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="number">8</span><span class="special">)</span> <span class="special">|</span> <span class="keyword">int</span><span class="special">(</span><span class="identifier">attr</span><span class="special">);</span>
<span class="special">};</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">foo_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">cu</span><span class="special">[</span><span class="identifier">record_first</span><span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">cu</span><span class="special">[</span><span class="identifier">check_against_first</span><span class="special">];</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">foo</span><span class="special">);</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">foo</span></code> matches the input if
        it can match two elements of the input in a row, but only if they are not
        the same value. Without locals, it's a lot harder to write parsers that have
        to track state as they parse.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h8"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.parameters"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.parameters">Parameters</a>
      </h5>
<p>
        Sometimes, it is convenient to parameterize parsers. Consider these parsing
        rules from the <a href="https://yaml.org/spec/1.2/spec.html" target="_top">YAML 1.2</a>
        spec:
      </p>
<pre class="programlisting">[80]
s-separate(n,BLOCK-OUT) ::= s-separate-lines(n)
s-separate(n,BLOCK-IN)  ::= s-separate-lines(n)
s-separate(n,FLOW-OUT)  ::= s-separate-lines(n)
s-separate(n,FLOW-IN)   ::= s-separate-lines(n)
s-separate(n,BLOCK-KEY) ::= s-separate-in-line
s-separate(n,FLOW-KEY)  ::= s-separate-in-line

[136]
in-flow(n,FLOW-OUT)  ::= ns-s-flow-seq-entries(n,FLOW-IN)
in-flow(n,FLOW-IN)   ::= ns-s-flow-seq-entries(n,FLOW-IN)
in-flow(n,BLOCK-KEY) ::= ns-s-flow-seq-entries(n,FLOW-KEY)
in-flow(n,FLOW-KEY)  ::= ns-s-flow-seq-entries(n,FLOW-KEY)

[137]
c-flow-sequence(n,c) ::= “[” s-separate(n,c)? in-flow(c)? “]”

</pre>
<p>
        YAML [137] says that the parsing should proceed into two YAML subrules, both
        of which have these <code class="computeroutput"><span class="identifier">n</span></code> and
        <code class="computeroutput"><span class="identifier">c</span></code> parameters. It is certainly
        possible to transliterate these YAML parsing rules to something that uses
        unparameterized Boost.Parser <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>, but it is quite painful
        to do so. It is better to use a parameterized rule.
      </p>
<p>
        You give parameters to a <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code> by calling its <code class="computeroutput"><span class="identifier">with</span><span class="special">()</span></code>
        member. The values you pass to <code class="computeroutput"><span class="identifier">with</span><span class="special">()</span></code> are used to create a <code class="computeroutput"><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a></code> that is available in
        semantic actions attached to the rule, using <code class="computeroutput"><a class="link" href="../../boost/parser/_params.html" title="Function template _params">_params</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>.
      </p>
<p>
        Passing parameters to <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code> like this allows you
        to easily write parsers that change the way they parse depending on contextual
        data that they have already parsed.
      </p>
<p>
        Here is an implementation of YAML [137]. It also implements the two YAML
        rules used directly by [137], rules [136] and [80]. The rules that <span class="bold"><strong>those</strong></span> rules use are also represented below, but are
        implemented using only <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>, so that I don't have
        to repeat too much of the (very large) YAML spec.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="comment">// A type to represent the YAML parse context.</span>
<span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">context</span> <span class="special">{</span>
    <span class="identifier">block_in</span><span class="special">,</span>
    <span class="identifier">block_out</span><span class="special">,</span>
    <span class="identifier">block_key</span><span class="special">,</span>
    <span class="identifier">flow_in</span><span class="special">,</span>
    <span class="identifier">flow_out</span><span class="special">,</span>
    <span class="identifier">flow_key</span>
<span class="special">};</span>

<span class="comment">// A YAML value; no need to fill it in for this example.</span>
<span class="keyword">struct</span> <span class="identifier">value</span>
<span class="special">{</span>
    <span class="comment">// ...</span>
<span class="special">};</span>

<span class="comment">// YAML [66], just stubbed in here.</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">s_separate_in_line</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>

<span class="comment">// YAML [137].</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">c_flow_seq_tag</span><span class="special">,</span> <span class="identifier">value</span><span class="special">&gt;</span> <span class="identifier">c_flow_sequence</span> <span class="special">=</span> <span class="string">"c-flow-sequence"</span><span class="special">;</span>
<span class="comment">// YAML [80].</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">s_separate_tag</span><span class="special">&gt;</span> <span class="identifier">s_separate</span> <span class="special">=</span> <span class="string">"s-separate"</span><span class="special">;</span>
<span class="comment">// YAML [136].</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">in_flow_tag</span><span class="special">,</span> <span class="identifier">value</span><span class="special">&gt;</span> <span class="identifier">in_flow</span> <span class="special">=</span> <span class="string">"in-flow"</span><span class="special">;</span>
<span class="comment">// YAML [138]; just eps below.</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">ns_s_flow_seq_entries_tag</span><span class="special">,</span> <span class="identifier">value</span><span class="special">&gt;</span> <span class="identifier">ns_s_flow_seq_entries</span> <span class="special">=</span>
    <span class="string">"ns-s-flow-seq-entries"</span><span class="special">;</span>
<span class="comment">// YAML [81]; just eps below.</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">s_separate_lines_tag</span><span class="special">&gt;</span> <span class="identifier">s_separate_lines</span> <span class="special">=</span> <span class="string">"s-separate-lines"</span><span class="special">;</span>

<span class="comment">// Parser for YAML [137].</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">c_flow_sequence_def</span> <span class="special">=</span>
    <span class="char">'['</span> <span class="special">&gt;&gt;</span>
    <span class="special">-</span><span class="identifier">s_separate</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;)</span> <span class="special">&gt;&gt;</span>
    <span class="special">-</span><span class="identifier">in_flow</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;)</span> <span class="special">&gt;&gt;</span>
    <span class="char">']'</span><span class="special">;</span>
<span class="comment">// Parser for YAML [80].</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">s_separate_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">switch_</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;)</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">block_out</span><span class="special">,</span> <span class="identifier">s_separate_lines</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;))</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">block_in</span><span class="special">,</span> <span class="identifier">s_separate_lines</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;))</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_out</span><span class="special">,</span> <span class="identifier">s_separate_lines</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;))</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_in</span><span class="special">,</span> <span class="identifier">s_separate_lines</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;))</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">block_key</span><span class="special">,</span> <span class="identifier">s_separate_in_line</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_key</span><span class="special">,</span> <span class="identifier">s_separate_in_line</span><span class="special">);</span>
<span class="comment">// Parser for YAML [136].</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">in_flow_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">switch_</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;)</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_out</span><span class="special">,</span> <span class="identifier">ns_s_flow_seq_entries</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;,</span> <span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_in</span><span class="special">))</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_in</span><span class="special">,</span> <span class="identifier">ns_s_flow_seq_entries</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;,</span> <span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_in</span><span class="special">))</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">block_out</span><span class="special">,</span> <span class="identifier">ns_s_flow_seq_entries</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;,</span> <span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_key</span><span class="special">))</span>
    <span class="special">(</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_key</span><span class="special">,</span> <span class="identifier">ns_s_flow_seq_entries</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;,</span> <span class="identifier">context</span><span class="special">::</span><span class="identifier">flow_key</span><span class="special">));</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">ns_s_flow_seq_entries_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">s_separate_lines_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>

<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span>
    <span class="identifier">c_flow_sequence</span><span class="special">,</span>
    <span class="identifier">s_separate</span><span class="special">,</span>
    <span class="identifier">in_flow</span><span class="special">,</span>
    <span class="identifier">ns_s_flow_seq_entries</span><span class="special">,</span>
    <span class="identifier">s_separate_lines</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        YAML [137] (<code class="computeroutput"><span class="identifier">c_flow_sequence</span></code>)
        parses a list. The list may be empty, and must be surrounded by brackets,
        as you see here. But, depending on the current YAML context (the <code class="computeroutput"><span class="identifier">c</span></code> parameter to [137]), we may require certain
        spacing to be matched by <code class="computeroutput"><span class="identifier">s</span><span class="special">-</span><span class="identifier">separate</span></code>,
        and how sub-parser <code class="computeroutput"><span class="identifier">in</span><span class="special">-</span><span class="identifier">flow</span></code> behaves also depends on the current
        context.
      </p>
<p>
        In <code class="computeroutput"><span class="identifier">s_separate</span></code> above, we parse
        differently based on the value of <code class="computeroutput"><span class="identifier">c</span></code>.
        This is done above by using the value of the second parameter to <code class="computeroutput"><span class="identifier">s_separate</span></code> in a switch-parser. The second
        parameter is looked up by using <code class="computeroutput"><a class="link" href="../../boost/parser/_p.html" title="Global _p">_p</a></code> as a parse argument.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">in_flow</span></code> does something similar.
        Note that <code class="computeroutput"><span class="identifier">in_flow</span></code> calls its
        subrule by passing its first parameter, but using a fixed value for the second
        value. <code class="computeroutput"><span class="identifier">s_separate</span></code> only passes
        its <code class="computeroutput"><span class="identifier">n</span></code> parameter conditionally.
        The point is that a rule can be used with and without <code class="computeroutput"><span class="special">.</span><span class="identifier">with</span><span class="special">()</span></code>,
        and that you can pass constants or parse arguments to <code class="computeroutput"><span class="special">.</span><span class="identifier">with</span><span class="special">()</span></code>.
      </p>
<p>
        With those rules defined, we could write a unit test for YAML [137] like
        this:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">test_parser</span> <span class="special">=</span> <span class="identifier">c_flow_sequence</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="number">4</span><span class="special">,</span> <span class="identifier">context</span><span class="special">::</span><span class="identifier">block_out</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"[]"</span><span class="special">,</span> <span class="identifier">test_parser</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">result</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        You could extend this with tests for different values of <code class="computeroutput"><span class="identifier">n</span></code>
        and <code class="computeroutput"><span class="identifier">c</span></code>. Obviously, in real
        tests, you parse actual contents inside the <code class="computeroutput"><span class="string">"[]"</span></code>,
        if the other rules were implemented, like [138].
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h9"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.the__globalname_alt__boost__parser___p___code__phrase_role__identifier___p__phrase___code___globalname__variable_template"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.the__globalname_alt__boost__parser___p___code__phrase_role__identifier___p__phrase___code___globalname__variable_template">The
        _p
        variable template</a>
      </h5>
<p>
        Getting at one of a rule's arguments and passing it as an argument to another
        parser can be very verbose. <code class="computeroutput"><a class="link" href="../../boost/parser/_p.html" title="Global _p">_p</a></code> is a variable template
        that allows you to refer to the <code class="computeroutput"><span class="identifier">n</span></code>th
        argument to the current rule, so that you can, in turn, pass it to one of
        the rule's subparsers. Using this, <code class="computeroutput"><span class="identifier">foo_def</span></code>
        above can be rewritten as:
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">foo_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">repeat</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;)[</span><span class="char">' '</span><span class="identifier">_l</span><span class="special">];</span>
</pre>
<p>
        Using <code class="computeroutput"><a class="link" href="../../boost/parser/_p.html" title="Global _p">_p</a></code>
        can prevent you from having to write a bunch of lambdas that get each get
        an argument out of the parse context using <code class="computeroutput"><a class="link" href="../../boost/parser/_params.html" title="Function template _params">_params</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)[</span><span class="number">0</span><span class="identifier">_c</span><span class="special">]</span></code> or
        similar.
      </p>
<p>
        Note that <code class="computeroutput"><a class="link" href="../../boost/parser/_p.html" title="Global _p">_p</a></code>
        is a parse argument (see <a class="link" href="the_parsers_and_their_uses.html" title="The Parsers And Their Uses">The
        Parsers And Their Uses</a>), meaning that it is an invocable that takes
        the context as its only parameter. If you want to use it inside a semantic
        action, you have to call it.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h10"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.special_forms_of_semantic_actions_usable_within_a_rule"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.special_forms_of_semantic_actions_usable_within_a_rule">Special
        forms of semantic actions usable within a rule</a>
      </h5>
<p>
        Semantic actions in this tutorial are usually of the signature <code class="computeroutput"><span class="keyword">void</span> <span class="special">(</span><span class="keyword">auto</span>
        <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span></code>. That is, they take a context by reference,
        and return nothing. If they were to return something, that something would
        just get dropped on the floor.
      </p>
<p>
        It is a pretty common pattern to create a rule in order to get a certain
        kind of value out of a parser, when you don't normally get it automatically.
        If I want to parse an <code class="computeroutput"><span class="keyword">int</span></code>,
        <code class="computeroutput"><a class="link" href="../../boost/parser/int_.html" title="Global int_">int_</a></code>
        does that, and the thing that I parsed is also the desired attribute. If
        I parse an <code class="computeroutput"><span class="keyword">int</span></code> followed by a
        <code class="computeroutput"><span class="keyword">double</span></code>, I get a <code class="computeroutput"><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a></code> containing one of each.
        But what if I don't want those two values, but some function of those two
        values? I probably write something like this.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">obj_t</span> <span class="special">{</span> <span class="comment">/* ... */</span> <span class="special">};</span>
<span class="identifier">obj_t</span> <span class="identifier">to_obj</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">d</span><span class="special">)</span> <span class="special">{</span> <span class="comment">/* ... */</span> <span class="special">}</span>

<span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">obj_tag</span><span class="special">,</span> <span class="identifier">obj_t</span><span class="special">&gt;</span> <span class="identifier">obj</span> <span class="special">=</span> <span class="string">"obj"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">make_obj</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>
    <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">to_obj</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)[</span><span class="number">0</span><span class="identifier">_c</span><span class="special">],</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)[</span><span class="number">1</span><span class="identifier">_c</span><span class="special">]);</span>
<span class="special">};</span>
<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">obj_def</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">&gt;&gt;</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span><span class="special">)[</span><span class="identifier">make_obj</span><span class="special">];</span>
</pre>
<p>
        That's fine, if a little verbose. However, you can also do this instead:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">obj_tag</span><span class="special">,</span> <span class="identifier">obj_t</span><span class="special">&gt;</span> <span class="identifier">obj</span> <span class="special">=</span> <span class="string">"obj"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">make_obj</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">to_obj</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)[</span><span class="number">0</span><span class="identifier">_c</span><span class="special">],</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)[</span><span class="number">1</span><span class="identifier">_c</span><span class="special">]);</span>
<span class="special">};</span>
<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">obj_def</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">&gt;&gt;</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span><span class="special">)[</span><span class="identifier">make_obj</span><span class="special">];</span>
</pre>
<p>
        Above, we return the value from a semantic action, and the returned value
        gets assigned to <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function _val">_val</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>.
      </p>
<p>
        Finally, you can provide a function that takes the individual elements of
        the attribute (if it's a tuple), and returns the value to assign to <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function _val">_val</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">obj_tag</span><span class="special">,</span> <span class="identifier">obj_t</span><span class="special">&gt;</span> <span class="identifier">obj</span> <span class="special">=</span> <span class="string">"obj"</span><span class="special">;</span>
<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">obj_def</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">&gt;&gt;</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span><span class="special">)[</span><span class="identifier">to_obj</span><span class="special">];</span>
</pre>
<p>
        More formally, within a rule, the use of a semantic action is determined
        as follows. Assume we have a function <code class="computeroutput"><span class="identifier">APPLY</span></code>
        that calls a function with the elements of a tuple, like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">apply</span></code>.
        For some context <code class="computeroutput"><span class="identifier">ctx</span></code>, semantic
        action <code class="computeroutput"><span class="identifier">action</span></code>, and attribute
        <code class="computeroutput"><span class="identifier">attr</span></code>, <code class="computeroutput"><span class="identifier">action</span></code>
        is used like this:
      </p>
<p>
        - <code class="computeroutput"><span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span>
        <span class="identifier">APPLY</span><span class="special">(</span><span class="identifier">action</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">attr</span><span class="special">))</span></code>,
        if that is well-formed, and <code class="computeroutput"><span class="identifier">attr</span></code>
        is a tuple of size 2 or larger;
      </p>
<p>
        - otherwise, <code class="computeroutput"><span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span>
        <span class="identifier">action</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>, if
        that is well-formed;
      </p>
<p>
        - otherwise, <code class="computeroutput"><span class="identifier">action</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>.
      </p>
<p>
        The first case does not pass the context to the action at all. The last case
        is the normal use of semantic actions outside of rules.
      </p>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="the__parse____api.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="algorithms_and_views_that_use_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
