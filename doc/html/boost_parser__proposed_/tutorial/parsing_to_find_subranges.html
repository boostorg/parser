<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Parsing to Find Subranges</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="semantic_actions.html" title="Semantic Actions">
<link rel="next" href="the_parse_context.html" title="The Parse Context">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="semantic_actions.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="the_parse_context.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.parsing_to_find_subranges"></a><a class="link" href="parsing_to_find_subranges.html" title="Parsing to Find Subranges">Parsing
      to Find Subranges</a>
</h3></div></div></div>
<p>
        So far we've seen examples that parse some text and generate associated attributes.
        Sometimes, you want to find some subrange of the input that contains what
        you're looking for, and you don't want to generate attributes at all.
      </p>
<p>
        There are two <span class="emphasis"><em>directive</em></span>s that affect the attribute type
        of any parser, <code class="computeroutput"><a class="link" href="../../boost/parser/raw.html" title="Global raw">raw[]</a></code> and <code class="computeroutput"><a class="link" href="../../boost/parser/string_view.html" title="Global string_view">string_view[]</a></code>.
        (We'll get to directives in more detail in the <a class="link" href="directives.html" title="Directives">Directives</a>
        section later. For now, you just need to know that a directive wraps a parser,
        and changes some aspect of how it functions.)
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.parsing_to_find_subranges.h0"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.parsing_to_find_subranges._globalname_alt__boost__parser__raw___code__phrase_role__identifier__raw__phrase__phrase_role__special______phrase___code___globalname_"></a></span><a class="link" href="parsing_to_find_subranges.html#boost_parser__proposed_.tutorial.parsing_to_find_subranges._globalname_alt__boost__parser__raw___code__phrase_role__identifier__raw__phrase__phrase_role__special______phrase___code___globalname_">raw[]</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/raw.html" title="Global raw">raw[]</a></code> changes the attribute of its
        parser to be a <code class="computeroutput"><a class="link" href="../../boost/parser/subrange.html" title="Struct template subrange">subrange</a></code>
        whose <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
        and <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>
        return the bounds of the sequence being parsed that match <code class="computeroutput"><span class="identifier">p</span></code>.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">int_parser</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">%</span> <span class="char">','</span><span class="special">;</span>            <span class="comment">// ATTR(int_parser) is std::vector&lt;int&gt;</span>
<span class="keyword">auto</span> <span class="identifier">subrange_parser</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">raw</span><span class="special">[</span><span class="identifier">int_parser</span><span class="special">];</span>  <span class="comment">// ATTR(subrange_parser) is a subrange</span>

<span class="comment">// Parse using int_parser, generating integers.</span>
<span class="keyword">auto</span> <span class="identifier">ints</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"1, 2, 3, 4"</span><span class="special">,</span> <span class="identifier">int_parser</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">ints</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(*</span><span class="identifier">ints</span> <span class="special">==</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;({</span><span class="number">1</span><span class="special">,</span> <span class="number">2</span><span class="special">,</span> <span class="number">3</span><span class="special">,</span> <span class="number">4</span><span class="special">}));</span>

<span class="comment">// Parse again using int_parser, but this time generating only the</span>
<span class="comment">// subrange matched by int_parser.  (prefix_parse() allows matches that</span>
<span class="comment">// don't consume the entire input.)</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">str</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"1, 2, 3, 4, a, b, c"</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">first</span> <span class="special">=</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
<span class="keyword">auto</span> <span class="identifier">range</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">prefix_parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">subrange_parser</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">range</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">range</span><span class="special">-&gt;</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">range</span><span class="special">-&gt;</span><span class="identifier">end</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">+</span> <span class="number">10</span><span class="special">);</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same_v</span><span class="special">&lt;</span>
              <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">range</span><span class="special">),</span>
              <span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">subrange</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span><span class="special">&gt;&gt;&gt;);</span>
</pre>
<p>
        Note that the <code class="computeroutput"><a class="link" href="../../boost/parser/subrange.html" title="Struct template subrange">subrange</a></code>
        has the iterator type <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span></code>,
        because that's the iterator type passed to <code class="computeroutput"><a class="link" href="../../boost/parser/prefix_parse_idm32502.html" title="Function template prefix_parse">prefix_parse()</a></code>.
        If we had passed <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
        <span class="special">*</span></code> iterators to <code class="computeroutput"><a class="link" href="../../boost/parser/prefix_parse_idm32502.html" title="Function template prefix_parse">prefix_parse()</a></code>,
        that would have been the iterator type. The only exception to this comes
        from Unicode-aware parsing (see <a class="link" href="unicode_support.html" title="Unicode Support">Unicode
        Support</a>). In some of those cases, the iterator being used in the parse
        is not the one you passed. For instance, if you call <code class="computeroutput"><a class="link" href="../../boost/parser/prefix_parse_idm32502.html" title="Function template prefix_parse">prefix_parse()</a></code>
        with <code class="computeroutput"><span class="identifier">char8_t</span> <span class="special">*</span></code>
        iterators, it will create a UTF-8 to UTF-32 transcoding view, and parse the
        iterators of that view. In such a case, you'll get a <code class="computeroutput"><a class="link" href="../../boost/parser/subrange.html" title="Struct template subrange">subrange</a></code> whose iterator type
        is a transcoding iterator. When that happens, you can get the underlying
        iterator — the one you passed to <code class="computeroutput"><a class="link" href="../../boost/parser/prefix_parse_idm32502.html" title="Function template prefix_parse">prefix_parse()</a></code>
        — by calling the <code class="computeroutput"><span class="special">.</span><span class="identifier">base</span><span class="special">()</span></code> member function on each transcoding iterator
        in the returned <code class="computeroutput"><a class="link" href="../../boost/parser/subrange.html" title="Struct template subrange">subrange</a></code>.
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">u8str</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">u8string</span><span class="special">(</span><span class="identifier">u8</span><span class="string">"1, 2, 3, 4, a, b, c"</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">u8first</span> <span class="special">=</span> <span class="identifier">u8str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
<span class="keyword">auto</span> <span class="identifier">u8range</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">prefix_parse</span><span class="special">(</span><span class="identifier">u8first</span><span class="special">,</span> <span class="identifier">u8str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">subrange_parser</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">u8range</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">u8range</span><span class="special">-&gt;</span><span class="identifier">begin</span><span class="special">().</span><span class="identifier">base</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">u8str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">u8range</span><span class="special">-&gt;</span><span class="identifier">end</span><span class="special">().</span><span class="identifier">base</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">u8str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">+</span> <span class="number">10</span><span class="special">);</span>
</pre>
<h5>
<a name="boost_parser__proposed_.tutorial.parsing_to_find_subranges.h1"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.parsing_to_find_subranges._globalname_alt__boost__parser__string_view___code__phrase_role__identifier__string_view__phrase__phrase_role__special______phrase___code___globalname_"></a></span><a class="link" href="parsing_to_find_subranges.html#boost_parser__proposed_.tutorial.parsing_to_find_subranges._globalname_alt__boost__parser__string_view___code__phrase_role__identifier__string_view__phrase__phrase_role__special______phrase___code___globalname_">string_view[]</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/string_view.html" title="Global string_view">string_view[]</a></code> has very similar semantics
        to <code class="computeroutput"><a class="link" href="../../boost/parser/raw.html" title="Global raw">raw[]</a></code>, except that it produces a
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string_view</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;</span></code>
        (where <code class="computeroutput"><span class="identifier">CharT</span></code> is the type
        of the underlying range begin parsed) instead of a <code class="computeroutput"><a class="link" href="../../boost/parser/subrange.html" title="Struct template subrange">subrange</a></code>. For this to work,
        the underlying range must be contiguous. Contiguity of iterators is not detectable
        before C++20, so this directive is only available in C++20 and later.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">int_parser</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">%</span> <span class="char">','</span><span class="special">;</span>              <span class="comment">// ATTR(int_parser) is std::vector&lt;int&gt;</span>
<span class="keyword">auto</span> <span class="identifier">sv_parser</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">string_view</span><span class="special">[</span><span class="identifier">int_parser</span><span class="special">];</span>  <span class="comment">// ATTR(subrange_parser) is a string_view</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">str</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"1, 2, 3, 4, a, b, c"</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">first</span> <span class="special">=</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
<span class="keyword">auto</span> <span class="identifier">sv1</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">prefix_parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">sv_parser</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">sv1</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(*</span><span class="identifier">sv1</span> <span class="special">==</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">substr</span><span class="special">(</span><span class="number">0</span><span class="special">,</span> <span class="number">10</span><span class="special">));</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same_v</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">sv1</span><span class="special">),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span><span class="special">&gt;&gt;);</span>
</pre>
<p>
        Since <code class="computeroutput"><a class="link" href="../../boost/parser/string_view.html" title="Global string_view">string_view[]</a></code> produces <code class="computeroutput"><span class="identifier">string_view</span></code>s,
        it cannot return transcoding iterators as described above for <code class="computeroutput"><a class="link" href="../../boost/parser/raw.html" title="Global raw">raw[]</a></code>. If you parse a sequence of
        <code class="computeroutput"><span class="identifier">CharT</span></code> with <code class="computeroutput"><a class="link" href="../../boost/parser/string_view.html" title="Global string_view">string_view[]</a></code>,
        you get exactly a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string_view</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;</span></code>.
        If the parse is using transcoding in the Unicode-aware path, <code class="computeroutput"><a class="link" href="../../boost/parser/string_view.html" title="Global string_view">string_view[]</a></code> will decompose the transcoding
        iterator as necessary. If you pass a transcoding view to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32538.html" title="Function template parse">parse()</a></code>
        or transcoding iterators to <code class="computeroutput"><a class="link" href="../../boost/parser/prefix_parse_idm32502.html" title="Function template prefix_parse">prefix_parse()</a></code>,
        <code class="computeroutput"><a class="link" href="../../boost/parser/string_view.html" title="Global string_view">string_view[]</a></code> will still see through the
        transcoding iterators without issue, and give you a <code class="computeroutput"><span class="identifier">string_view</span></code>
        of part of the underlying range.
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">sv2</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"1, 2, 3, 4"</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">as_utf32</span><span class="special">,</span> <span class="identifier">sv_parser</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">sv2</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(*</span><span class="identifier">sv2</span> <span class="special">==</span> <span class="string">"1, 2, 3, 4"</span><span class="special">);</span>

<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_same_v</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">sv2</span><span class="special">),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span><span class="special">&gt;&gt;);</span>
</pre>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="semantic_actions.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="the_parse_context.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
