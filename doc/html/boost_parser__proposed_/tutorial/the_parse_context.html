<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The Parse Context</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="parsing_to_find_subranges.html" title="Parsing to Find Subranges">
<link rel="next" href="rule_parsers.html" title="Rule Parsers">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="parsing_to_find_subranges.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="rule_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.the_parse_context"></a><a class="link" href="the_parse_context.html" title="The Parse Context">The
      Parse Context</a>
</h3></div></div></div>
<p>
        Now would be a good time to describe the parse context in some detail. Any
        semantic action that you write will need to use state in the parse context,
        so you need to know what's available.
      </p>
<p>
        The parse context is an object that stores the current state of the parse
        — the current- and end-iterators, the error handler, etc. Data may
        seem to be "added" to or "removed" from it at different
        times during the parse. For instance, when a parser <code class="computeroutput"><span class="identifier">p</span></code>
        with a semantic action <code class="computeroutput"><span class="identifier">a</span></code>
        succeeds, the context adds the attribute that <code class="computeroutput"><span class="identifier">p</span></code>
        produces to the parse context, then calls <code class="computeroutput"><span class="identifier">a</span></code>,
        passing it the context.
      </p>
<p>
        Though the context object appears to have things added to or removed from
        it, it does not. In reality, there is no one context object. Contexts are
        formed at various times during the parse, usually when starting a subparser.
        Each context is formed by taking the previous context and adding or changing
        members as needed to form a new context object. When the function containing
        the new context object returns, its context object (if any) is destructed.
        This is efficient to do, because the parse context has only about a dozen
        data members, and each data member is less than or equal to the size of a
        pointer. Copying the entire context when mutating the context is therefore
        fast. The context does no memory allocation.
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          All these functions that take the parse context as their first parameter
          will find by found by Argument-Dependent Lookup. You will probably never
          need to qualify them with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">::</span></code>.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h0"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_always_available"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_always_available">Accessors
        for data that are always available</a>
      </h5>
<p>
        By convention, the names of all Boost.Parser functions that take a parse
        context, and are therefore intended for use inside semantic actions, contain
        a leading underscore.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h1"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___pass___code__phrase_role__identifier___pass__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___pass___code__phrase_role__identifier___pass__phrase__phrase_role__special______phrase___code___functionname_">_pass()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_pass.html" title="Function template _pass">_pass()</a></code> returns a reference to a
        <code class="computeroutput"><span class="keyword">bool</span></code> indicating the success
        of failure of the current parse. This can be used to force the current parse
        to pass or fail:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// If the attribute fails to meet this predicate, fail the parse.</span>
    <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">necessary_condition</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)))</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        Note that for a semantic action to be executed, its associated parser must
        already have succeeded. So unless you previously wrote <code class="computeroutput"><span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span>
        <span class="special">=</span> <span class="keyword">false</span></code>
        within your action, <code class="computeroutput"><span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span>
        <span class="special">=</span> <span class="keyword">true</span></code>
        does nothing; it's redundant.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h2"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___begin___code__phrase_role__identifier___begin__phrase__phrase_role__special______phrase___code___functionname____functionname_alt__boost__parser___end___code__phrase_role__identifier___end__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___where___code__phrase_role__identifier___where__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___begin___code__phrase_role__identifier___begin__phrase__phrase_role__special______phrase___code___functionname____functionname_alt__boost__parser___end___code__phrase_role__identifier___end__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___where___code__phrase_role__identifier___where__phrase__phrase_role__special______phrase___code___functionname_">_begin(), _end()
        and _where()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_begin.html" title="Function template _begin">_begin()</a></code> and <code class="computeroutput"><a class="link" href="../../boost/parser/_end.html" title="Function template _end">_end()</a></code>
        return the beginning and end of the range that you passed to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32573.html" title="Function template parse">parse()</a></code>, respectively. <code class="computeroutput"><a class="link" href="../../boost/parser/_where.html" title="Function template _where">_where()</a></code> returns a <code class="computeroutput"><a class="link" href="../../boost/parser/subrange.html" title="Struct template subrange">subrange</a></code> indicating the bounds
        of the input matched by the current parse. <code class="computeroutput"><a class="link" href="../../boost/parser/_where.html" title="Function template _where">_where()</a></code>
        can be useful if you just want to parse some text and return a result consisting
        of where certain elements are located, without producing any other attributes.
        <code class="computeroutput"><a class="link" href="../../boost/parser/_where.html" title="Function template _where">_where()</a></code> can also be essential in
        tracking where things are located, to provide good diagnostics at a later
        point in the parse. Think mismatched tags in XML; if you parse a close-tag
        at the end of an element, and it does not match the open-tag, you want to
        produce an error message that mentions or shows both tags. Stashing <code class="computeroutput"><a class="link" href="../../boost/parser/_where.html" title="Function template _where">_where</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">begin</span><span class="special">()</span></code>
        somewhere that is available to the close-tag parser will enable that. See
        <a class="link" href="error_handling_and_debugging.html" title="Error Handling and Debugging">Error
        Handling and Debugging</a> for an example of this.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h3"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___error_handler___code__phrase_role__identifier___error_handler__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___error_handler___code__phrase_role__identifier___error_handler__phrase__phrase_role__special______phrase___code___functionname_">_error_handler()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_error_handler.html" title="Function template _error_handler">_error_handler()</a></code> returns a reference to the
        error handler associated with the parser passed to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm32573.html" title="Function template parse">parse()</a></code>.
        Using <code class="computeroutput"><a class="link" href="../../boost/parser/_error_handler.html" title="Function template _error_handler">_error_handler()</a></code>, you can generate errors
        and warnings from within your semantic actions. See <a class="link" href="error_handling_and_debugging.html" title="Error Handling and Debugging">Error
        Handling and Debugging</a> for concrete examples.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h4"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_only_sometimes_available"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_only_sometimes_available">Accessors
        for data that are only sometimes available</a>
      </h5>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h5"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___attr___code__phrase_role__identifier___attr__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___attr___code__phrase_role__identifier___attr__phrase__phrase_role__special______phrase___code___functionname_">_attr()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_attr.html" title="Function template _attr">_attr()</a></code> returns a reference to the
        value of the current parser's attribute. It is available only when the current
        parser's parse is successful. If the parser has no semantic action, no attribute
        gets added to the parse context. It can be used to read and write the current
        parser's attribute:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="number">3</span><span class="special">;</span> <span class="special">}</span>
</pre>
<p>
        If the current parser has no attribute, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code> is returned.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h6"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_">_val()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function _val">_val()</a></code> returns a reference to the
        value of the attribute of the current rule being used to parse (if any),
        and is available even before the rule's parse is successful. It can be used
        to set the current rule's attribute, even from a parser that is a subparser
        inside the rule. Let's say we're writing a parser with a semantic action
        that is within a rule. If we want to set the current rule's value to some
        function of subparser's attribute, we would write this semantic action:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">some_function</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">));</span> <span class="special">}</span>
</pre>
<p>
        If there is no current rule, or the current rule has no attribute, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
        is returned.
      </p>
<p>
        You need to use <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function _val">_val()</a></code> in cases where the default
        attribute for a <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>'s
        parser is not directly compatible with the attribute type of the <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>.
        In these cases, you'll need to write some code like the example above to
        compute the <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>'s
        attribute from the <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>'s
        parser's generated attribute. For more info on <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>, see the next page, and
        <a class="link" href="more_about_rules.html" title="More About Rules">More About
        Rules</a>.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h7"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___globals___code__phrase_role__identifier___globals__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___globals___code__phrase_role__identifier___globals__phrase__phrase_role__special______phrase___code___functionname_">_globals()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_globals.html" title="Function template _globals">_globals()</a></code> returns a reference to a
        user-supplied object that contains whatever data you want to use during the
        parse. The "globals" for a parse is an object — typically
        a struct — that you give to the top-level parser. Then you can use
        <code class="computeroutput"><a class="link" href="../../boost/parser/_globals.html" title="Function template _globals">_globals()</a></code> to access it at any time
        during the parse. We'll see how globals get associated with the top-level
        parser in <a class="link" href="the__parse____api.html" title="The parse() API">The
        <code class="computeroutput"><span class="identifier">parse</span><span class="special">()</span></code>
        API</a> later. As an example, say that you have an early part of the parse
        that needs to record some black-listed values, and that later parts of the
        parse might need to parse values, failing the parse if they see the black-listed
        values. In the early part of the parse, you could write something like this.
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// black_list is a std::unordered_set.</span>
    <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">black_list</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
        Later in the parse, you could then use <code class="computeroutput"><span class="identifier">black_list</span></code>
        to check values as they are parsed.
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">black_list</span><span class="special">.</span><span class="identifier">contains</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)))</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h8"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___locals___code__phrase_role__identifier___locals__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___locals___code__phrase_role__identifier___locals__phrase__phrase_role__special______phrase___code___functionname_">_locals()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code> returns a reference to one
        or more values that are local to the current rule being parsed, if any. If
        there are two or more local values, <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>
        returns a reference to a <code class="computeroutput"><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a></code>. Rules with locals are
        something we haven't gotten to yet (see <a class="link" href="more_about_rules.html" title="More About Rules">More
        About Rules</a>), but for now all you need to know is that you can provide
        a template parameter (<code class="computeroutput"><span class="identifier">LocalState</span></code>)
        to <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>,
        and the rule will default construct an object of that type for use within
        the rule. You access it via <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">local</span> <span class="special">=</span> <span class="identifier">_locals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span>
    <span class="comment">// Use local here.  If 'local' is a hana::tuple, access its members like this:</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">hana</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>
    <span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">first_element</span> <span class="special">=</span> <span class="identifier">local</span><span class="special">[</span><span class="number">0</span><span class="identifier">_c</span><span class="special">];</span>
    <span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">second_element</span> <span class="special">=</span> <span class="identifier">local</span><span class="special">[</span><span class="number">1</span><span class="identifier">_c</span><span class="special">];</span>
<span class="special">}</span>
</pre>
<p>
        If there is no current rule, or the current rule has no locals, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
        is returned.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h9"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___params___code__phrase_role__identifier___params__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___params___code__phrase_role__identifier___params__phrase__phrase_role__special______phrase___code___functionname_">_params()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_params.html" title="Function template _params">_params()</a></code>, like <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>,
        applies to the current rule being used to parse, if any (see <a class="link" href="more_about_rules.html" title="More About Rules">More
        About Rules</a>). It also returns a reference to a single value, if the
        current rule has only one parameter, or a <code class="computeroutput"><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a></code> of multiple values if
        the current rule has multiple parameters. If there is no current rule, or
        the current rule has no parameters, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code> is returned.
      </p>
<p>
        Unlike with <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>, you <span class="bold"><strong>do
        not</strong></span> provide a template parameter to <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>. Instead you call the
        <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>'s
        <code class="computeroutput"><span class="identifier">with</span><span class="special">()</span></code>
        member function (again, see <a class="link" href="more_about_rules.html" title="More About Rules">More
        About Rules</a>).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
          is a type that is used as a return value in Boost.Parser for parse context
          accessors. <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
          is convertible to anything that has a default constructor, convertible
          from anything, assignable form anything, and has templated overloads for
          all the overloadable operators. The intention is that a misuse of <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function _val">_val()</a></code>, <code class="computeroutput"><a class="link" href="../../boost/parser/_globals.html" title="Function template _globals">_globals()</a></code>,
          etc. should compile, and produce an assertion at runtime. Experience has
          shown that using a debugger for investigating the stack that leads to your
          mistake is a far better user experience than sifting through compiler diagnostics.
          See the <a class="link" href="../rationale.html" title="Rationale">Rationale</a>
          section for a more detailed explanation.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h10"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___no_case___code__phrase_role__identifier___no_case__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___no_case___code__phrase_role__identifier___no_case__phrase__phrase_role__special______phrase___code___functionname_"><code class="computeroutput">_no_case()</code></a>
      </h5>
<p>
        <code class="computeroutput">_no_case()</code> returns <code class="computeroutput"><span class="keyword">true</span></code>
        if the current parse context is inside one or more (possibly nested) <code class="computeroutput"><a class="link" href="../../boost/parser/no_case.html" title="Global no_case">no_case[]</a></code> directives. I don't have a
        use case for this, but if I didn't expose it, it would be the only thing
        in the context that you could not examine from inside a semantic action.
        It was easy to add, so I did.
      </p>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="parsing_to_find_subranges.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="rule_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
